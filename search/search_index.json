{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"QPhase - A Modular Toolkit for Phase-Space Simulation in Quantum Optics","text":"<p>Get Started View on GitHub</p>"},{"location":"#overview","title":"Overview","text":"<p>QPhase is a lightweight, modular simulation toolset designed for physics research. It solves a common problem in scientific computing: the repetitive rewriting of \"boilerplate\" code for every new experiment.</p> <p>The Problem</p> <p>In typical physics research, we often rewrite the same supporting code:</p> <ul> <li>How do I pass parameters? (Argparse/Config)</li> <li>How do I save results safely?</li> <li>How do I switch to GPU?</li> <li>How do I scan parameters?</li> </ul> <p>QPhase separates these \"operational\" concerns from the actual \"physics\". It provides a stable Shell that handles configuration, data saving, and parallel execution, allowing you to write only the Kernel\u2014the equations of motion.</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#focus-on-physics","title":"Focus on Physics","text":"<p>You write the model (e.g., <code>dx/dt = ...</code>), and the framework handles the integration loop, progress bars, and file I/O.</p>"},{"location":"#reproducibility","title":"Reproducibility","text":"<p>Every run automatically saves a snapshot of the exact configuration used. Never lose track of what parameters produced a specific plot.</p>"},{"location":"#hardware-switching","title":"Hardware Switching","text":"<p>Switch between NumPy (CPU) and PyTorch/CuPy (GPU) just by changing a line in the config file, without rewriting your model.</p>"},{"location":"#parameter-sweeps","title":"Parameter Sweeps","text":"<p>Define a list of parameters in the config, and QPhase automatically generates and runs the batch jobs.</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#1-installation","title":"1. Installation","text":"<pre><code>pip install qphase\n</code></pre>"},{"location":"#2-run-a-simulation","title":"2. Run a Simulation","text":"<pre><code>qphase run config.yaml\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"Section Description User Guide Installation, configuration (YAML), and running jobs. Developer Guide Plugin system, architecture, and extending the framework. API Reference Technical details of the core classes."},{"location":"#project-status","title":"Project Status","text":"<p>This is a personal research project currently in active development. It is designed to be flexible enough for my own research needs in quantum phase-space simulations, but structured enough to be useful for others facing similar computational challenges.</p>"},{"location":"api/","title":"API Reference","text":"<p>This section contains the technical API documentation for the QPhase framework.</p>"},{"location":"api/#core-components","title":"Core Components","text":"<ul> <li>Core API: Core classes and interfaces (Scheduler, Registry, Configuration)</li> <li>SDE API: Stochastic Differential Equation engine and components</li> <li>Additional API documentation coming soon...</li> </ul> <p>Choose a component above to explore its API details!</p>"},{"location":"api/core/","title":"Core API Reference","text":"<p>This section documents the core components of the QPhase framework, including the Scheduler, Registry, and Configuration models.</p>"},{"location":"api/core/#scheduler","title":"Scheduler","text":"<p>The <code>Scheduler</code> is the central component responsible for orchestrating the execution of simulation jobs. It handles dependency resolution, parameter scanning, and result persistence.</p>"},{"location":"api/core/#class-qphasecorescheduler","title":"<code>class qphase.core.Scheduler</code>","text":"<p>Parameters:</p> <ul> <li><code>system_config</code> (<code>SystemConfig</code>, optional): The system configuration object. If not provided, it is loaded from <code>system.yaml</code>.</li> <li><code>default_output_dir</code> (<code>str</code>, optional): Overrides the default output directory specified in the system configuration.</li> <li><code>on_progress</code> (<code>Callable[[JobProgressUpdate], None]</code>, optional): A callback function invoked with progress updates during job execution.</li> <li><code>on_run_dir</code> (<code>Callable[[Path], None]</code>, optional): A callback function invoked with the path to the run directory after each job completes.</li> </ul> <p>Methods:</p>"},{"location":"api/core/#runjob_list-joblist-listjobresult","title":"<code>run(job_list: JobList) -&gt; list[JobResult]</code>","text":"<p>Executes a list of jobs serially. This method handles: 1.  Dependency Resolution: Ensures jobs are executed in the correct order based on their dependencies. 2.  Parameter Scanning: Expands jobs with scanable parameters into multiple tasks. 3.  Directory Management: Creates unique run directories for each job execution. 4.  Snapshotting: Saves configuration snapshots for reproducibility.</p> <p>Returns: *   <code>list[JobResult]</code>: A list of result objects containing execution status and metadata for each job.</p>"},{"location":"api/core/#configuration","title":"Configuration","text":""},{"location":"api/core/#class-qphasecorejobconfig","title":"<code>class qphase.core.JobConfig</code>","text":"<p>Represents the configuration for a single simulation job.</p> <p>Fields:</p> <ul> <li><code>name</code> (<code>str</code>): Required. A unique identifier for the job.</li> <li><code>engine</code> (<code>dict[str, Any]</code>): Required. Configuration for the simulation engine. Must contain exactly one key (the engine name) mapping to its configuration dictionary.</li> <li><code>plugins</code> (<code>dict[str, dict[str, Any]]</code>): Optional. Configuration for plugins, organized by plugin type (e.g., <code>backend</code>, <code>model</code>).</li> <li><code>params</code> (<code>dict[str, Any]</code>): Optional. A dictionary of job-specific parameters.</li> <li><code>input</code> (<code>str | None</code>): Optional. The name of an upstream job or a file path to use as input.</li> <li><code>output</code> (<code>str | None</code>): Optional. The output destination (filename or downstream job name).</li> <li><code>tags</code> (<code>list[str]</code>): Optional. A list of tags for categorization.</li> <li><code>depends_on</code> (<code>list[str]</code>): Optional. A list of job names that this job depends on.</li> </ul>"},{"location":"api/core/#class-qphasecoresystemconfig","title":"<code>class qphase.core.SystemConfig</code>","text":"<p>Represents the global system settings.</p> <p>Fields:</p> <ul> <li><code>paths</code> (<code>PathsConfig</code>): Directory paths for configuration, plugins, and output.</li> <li><code>auto_save_results</code> (<code>bool</code>): Whether to automatically save results to disk.</li> <li><code>parameter_scan</code> (<code>dict</code>): Settings for batch execution and parameter scanning strategies.</li> </ul>"},{"location":"api/core/#registry","title":"Registry","text":""},{"location":"api/core/#class-qphasecoreregistrycenter","title":"<code>class qphase.core.RegistryCenter</code>","text":"<p>The central registry for managing plugins. It supports dynamic discovery, registration, and factory-style instantiation of components.</p> <p>Methods:</p>"},{"location":"api/core/#registernamespace-str-name-str-target-any","title":"<code>register(namespace: str, name: str, target: Any)</code>","text":"<p>Registers a new plugin.</p> <ul> <li><code>namespace</code>: The category of the plugin (e.g., \"backend\", \"model\").</li> <li><code>name</code>: The unique name of the plugin within its namespace.</li> <li><code>target</code>: The plugin class or factory function.</li> </ul>"},{"location":"api/core/#createfull_name-str-config-any-none-kwargs-any","title":"<code>create(full_name: str, config: Any = None, **kwargs) -&gt; Any</code>","text":"<p>Instantiates a plugin.</p> <ul> <li><code>full_name</code>: The full identifier of the plugin (e.g., \"backend:numpy\").</li> <li><code>config</code>: The configuration object to pass to the plugin constructor.</li> <li><code>**kwargs</code>: Additional keyword arguments passed to the constructor.</li> </ul>"},{"location":"api/core/#listnamespace-str-none-none-dict","title":"<code>list(namespace: str | None = None) -&gt; dict</code>","text":"<p>Lists registered plugins.</p> <ul> <li><code>namespace</code>: If provided, filters the list to a specific namespace.</li> <li>Returns: A dictionary mapping plugin names to their metadata.</li> </ul>"},{"location":"api/sde/","title":"SDE API Reference","text":"<p>This section documents the <code>qphase_sde</code> package, which provides the core engine and components for stochastic differential equation simulations.</p>"},{"location":"api/sde/#engine","title":"Engine","text":""},{"location":"api/sde/#class-qphase_sdeengineengine","title":"<code>class qphase_sde.engine.Engine</code>","text":"<p>The main simulation driver. It orchestrates the integration loop, manages data storage, and handles progress reporting.</p> <p>Configuration (<code>EngineConfig</code>):</p> <ul> <li><code>dt</code> (<code>float</code>): Time step.</li> <li><code>t_max</code> (<code>float</code>): Simulation duration.</li> <li><code>n_traj</code> (<code>int</code>): Number of trajectories.</li> <li><code>integrator</code> (<code>dict</code>): Integrator settings.</li> <li><code>backend</code> (<code>str</code>): Backend name.</li> </ul> <p>Methods:</p>"},{"location":"api/sde/#runmodel-sdemodel-sderesult","title":"<code>run(model: SDEModel, ...) -&gt; SDEResult</code>","text":"<p>Executes the simulation for the given model.</p>"},{"location":"api/sde/#integrators","title":"Integrators","text":""},{"location":"api/sde/#protocol-qphase_sdeintegratorintegrator","title":"<code>protocol qphase_sde.integrator.Integrator</code>","text":"<p>The interface that all numerical solvers must implement.</p> <p>Methods:</p> <ul> <li><code>step(y, t, dt, model, noise, backend) -&gt; dy</code>: Performs a single fixed time step.</li> <li><code>step_adaptive(y, t, dt, tol, model, noise, backend, rng) -&gt; (y_next, t_next, dt_next, error)</code>: (Optional) Performs an adaptive time step.</li> </ul>"},{"location":"api/sde/#class-qphase_sdeintegratorgenericsrk","title":"<code>class qphase_sde.integrator.GenericSRK</code>","text":"<p>A generic Stochastic Runge-Kutta solver supporting multiple methods and adaptive stepping.</p> <p>Parameters:</p> <ul> <li><code>method</code> (<code>str</code>): The integration scheme to use (<code>\"euler\"</code>, <code>\"heun\"</code>).</li> <li><code>tol</code> (<code>float</code>, optional): Error tolerance for adaptive stepping.</li> </ul>"},{"location":"api/sde/#models","title":"Models","text":"<p>The <code>qphase_sde</code> package supports a hierarchical modeling approach.</p>"},{"location":"api/sde/#level-1-master-equation","title":"Level 1: Master Equation","text":""},{"location":"api/sde/#class-qphase_sdemodelmasterequation","title":"<code>class qphase_sde.model.MasterEquation</code>","text":"<p>Represents the system dynamics in Hilbert space.</p> <p>Attributes: *   <code>hamiltonian</code>: The Hamiltonian operator. *   <code>lindblad_ops</code>: List of Lindblad collapse operators.</p>"},{"location":"api/sde/#level-2-phase-space-fpe","title":"Level 2: Phase Space (FPE)","text":""},{"location":"api/sde/#class-qphase_sdemodelphasespacemodel","title":"<code>class qphase_sde.model.PhaseSpaceModel</code>","text":"<p>Represents the system dynamics in phase space via Kramers-Moyal coefficients.</p> <p>Attributes: *   <code>terms</code> (<code>dict[int, Any]</code>): Dictionary mapping order $n$ to coefficient $D_n(\\alpha)$.     *   $n=1$: Drift vector.     *   $n=2$: Diffusion tensor.</p>"},{"location":"api/sde/#level-3-stochastic-sde","title":"Level 3: Stochastic (SDE)","text":""},{"location":"api/sde/#protocol-qphase_sdemodelsdemodel","title":"<code>protocol qphase_sde.model.SDEModel</code>","text":"<p>The interface for defining physical systems consumed by the engine.</p> <p>Attributes:</p> <ul> <li><code>n_modes</code> (<code>int</code>): Dimension of the state vector.</li> <li><code>noise_dim</code> (<code>int</code>): Dimension of the noise vector.</li> <li><code>noise_basis</code> (<code>str</code>): <code>\"real\"</code> or <code>\"complex\"</code>.</li> </ul> <p>Methods:</p> <ul> <li><code>drift(y, t, params) -&gt; Any</code>: Computes the drift vector $\\mathbf{a}(\\mathbf{y}, t)$.</li> <li><code>diffusion(y, t, params) -&gt; Any</code>: Computes the diffusion matrix $\\mathbf{b}(\\mathbf{y}, t)$.</li> </ul>"},{"location":"api/sde/#class-qphase_sdemodeldiffusivesdemodel","title":"<code>class qphase_sde.model.DiffusiveSDEModel</code>","text":"<p>Concrete implementation for Langevin-type SDEs (Continuous, Gaussian noise).</p>"},{"location":"api/sde/#class-qphase_sdemodeljumpsdemodel","title":"<code>class qphase_sde.model.JumpSDEModel</code>","text":"<p>Concrete implementation for Jump-Diffusion SDEs.</p>"},{"location":"api/sde/#converters","title":"Converters","text":""},{"location":"api/sde/#qphase_sdemodelfpe_to_sdefpe-phasespacemodel-diffusivesdemodel","title":"<code>qphase_sde.model.fpe_to_sde(fpe: PhaseSpaceModel) -&gt; DiffusiveSDEModel</code>","text":"<p>Converts a 2nd-order PhaseSpaceModel to a DiffusiveSDEModel. *   Drift $A = D_1$ *   Diffusion $B = \\sqrt{D_2}$</p>"},{"location":"api/sde/#noise-specification","title":"Noise Specification","text":"<p>Defines the properties of the noise driving the system.</p> <p>Attributes:</p> <ul> <li><code>kind</code> (<code>str</code>): <code>\"independent\"</code> or <code>\"correlated\"</code>.</li> <li><code>dim</code> (<code>int</code>): Number of noise channels.</li> <li><code>covariance</code> (<code>Any</code>, optional): Covariance matrix for correlated noise.</li> </ul>"},{"location":"api/sde/#analyzers","title":"Analyzers","text":""},{"location":"api/sde/#protocol-qphase_sdeanalyseranalyzerprotocol","title":"<code>protocol qphase_sde.analyser.AnalyzerProtocol</code>","text":"<p>The interface for analysis plugins.</p> <p>Methods:</p> <ul> <li><code>analyze(data: Any, backend: BackendBase) -&gt; ResultProtocol</code>: Performs analysis on the simulation data.</li> </ul>"},{"location":"dev_guide/","title":"Developer Guide","text":"<p>Welcome to the QPhase Developer Guide! This section is for developers who want to understand the internal architecture, extend QPhase with new plugins, or contribute to the project.</p>"},{"location":"dev_guide/#core-architecture","title":"Core Architecture","text":"<ul> <li>Architecture Overview: High-level design philosophy and system architecture</li> <li>Protocols: Understanding the plugin system and interfaces</li> <li>Registry System: How plugins are discovered and loaded</li> <li>Scheduler: Execution flow and job management</li> </ul>"},{"location":"dev_guide/#extending-qphase","title":"Extending QPhase","text":"<ul> <li>Plugin Development: How to create new plugins (backends, analyzers, etc.)</li> <li>Backend Development: Creating custom computation backends</li> <li>Configuration: Advanced configuration options</li> </ul>"},{"location":"dev_guide/#advanced-topics","title":"Advanced Topics","text":"<ul> <li>Error Handling: Understanding errors and debugging</li> <li>FAQ: Frequently asked questions</li> </ul> <p>Choose a guide below to learn more about QPhase's internals!</p>"},{"location":"dev_guide/architecture/","title":"Architecture Overview","text":"<p>This document details the architectural design of the QPhase framework. It is intended for developers seeking to understand the internal mechanisms, design patterns, and structural decisions that govern the system.</p>"},{"location":"dev_guide/architecture/#design-philosophy","title":"Design Philosophy","text":"<p>QPhase is architected to address the specific challenges of scientific computing: reproducibility, modularity, and hardware agnosticism. Unlike ad-hoc scripting, where simulation logic is tightly coupled with infrastructure code (I/O, configuration, parallelization), QPhase enforces a strict separation of concerns.</p>"},{"location":"dev_guide/architecture/#the-shell-kernel-dichotomy","title":"The Shell-Kernel Dichotomy","text":"<p>The framework is conceptually divided into two distinct layers:</p> <ol> <li> <p>The Shell (Infrastructure Layer):</p> <ul> <li>Responsibility: Manages the operational lifecycle of a simulation. This includes configuration parsing, dependency injection, job scheduling, resource management, and result persistence.</li> <li>Characteristics: Generic, physics-agnostic, and stable. It provides the \"runtime environment\" for simulations.</li> </ul> </li> <li> <p>The Kernel (Domain Layer):</p> <ul> <li>Responsibility: Encapsulates the scientific logic. This includes physical models (Hamiltonians, Drift/Diffusion vectors), numerical integrators, and backend implementations.</li> <li>Characteristics: Domain-specific, modular, and extensible. Users primarily interact with this layer by implementing plugins.</li> </ul> </li> </ol>"},{"location":"dev_guide/architecture/#core-concepts","title":"Core Concepts","text":"<p>To understand how QPhase operates, it is essential to distinguish between three fundamental concepts: the Job, the Engine, and the Plugin.</p>"},{"location":"dev_guide/architecture/#1-the-job-the-intent","title":"1. The Job (The \"Intent\")","text":"<p>A Job represents a single, atomic execution request. It answers the question: \"What simulation do I want to run?\" *   Definition: A Job is defined entirely by its configuration (a resolved YAML document). It contains all the parameters needed to reproduce a simulation. *   Isolation: Each Job runs in its own isolated directory (<code>runs/{timestamp}_{job_name}/</code>). This ensures that side effects (like file I/O) from one simulation do not contaminate another. *   Lifecycle: A Job is created by the Scheduler (often by expanding a parameter scan), executed, and then finalized when its results are saved.</p>"},{"location":"dev_guide/architecture/#2-the-engine-the-workflow","title":"2. The Engine (The \"Workflow\")","text":"<p>An Engine is a special type of plugin that defines the lifecycle of a simulation. It answers the question: \"How should the simulation proceed?\" *   Role: The Engine acts as the \"main loop\" or orchestrator.     *   The <code>sde</code> engine runs a time-stepping loop for stochastic differential equations.     *   The <code>viz</code> engine runs a data processing and plotting pipeline. *   Orchestration: The Engine does not perform the low-level physics or math itself. Instead, it requests other plugins (like Models or Backends) to do the actual work.</p>"},{"location":"dev_guide/architecture/#3-the-plugin-the-building-block","title":"3. The Plugin (The \"Building Block\")","text":"<p>A Plugin is a modular component that implements a specific capability. Plugins are the \"Lego blocks\" that the Engine assembles to build a simulation. *   Model: Defines the physical system (e.g., drift and diffusion vectors). *   Backend: Provides the computational primitives (e.g., NumPy for CPU, PyTorch for GPU). *   Integrator: Implements the numerical solver (e.g., Euler-Maruyama). *   Analyser: Processes raw simulation data into metrics.</p>"},{"location":"dev_guide/architecture/#the-relationship-dependency-injection","title":"The Relationship: Dependency Injection","text":"<p>The power of QPhase lies in how these components connect. You do not write code to wire them together; the Scheduler does it for you based on the configuration.</p> <ol> <li>Selection: The Job configuration selects an Engine (e.g., <code>engine: sde</code>).</li> <li>Declaration: The Engine declares what it needs via a Manifest (e.g., \"I require a <code>model</code> and a <code>backend</code>\").</li> <li>Injection: The Scheduler reads the Manifest, looks up the requested plugins in the Job config, instantiates them via the Registry, and injects them into the Engine's constructor.</li> </ol>"},{"location":"dev_guide/architecture/#core-architectural-patterns","title":"Core Architectural Patterns","text":""},{"location":"dev_guide/architecture/#1-registry-pattern-dependency-injection","title":"1. Registry Pattern &amp; Dependency Injection","text":"<p>To achieve modularity, QPhase avoids hardcoded dependencies. Instead, it utilizes a Registry Pattern combined with Dependency Injection.</p> <ul> <li>Registry: A centralized singleton (<code>RegistryCenter</code>) that maintains a dynamic mapping of component names (strings) to their implementations (classes/factories). This allows components to be selected at runtime via configuration files.</li> <li>Dependency Injection: When an <code>Engine</code> is instantiated, it does not instantiate its dependencies (Model, Backend) directly. Instead, the <code>Scheduler</code> resolves these dependencies via the Registry and injects them into the Engine's constructor. This inversion of control facilitates testing and component swapping.</li> </ul>"},{"location":"dev_guide/architecture/#2-backend-abstraction-tensor-dispatching","title":"2. Backend Abstraction (Tensor Dispatching)","text":"<p>A critical requirement for modern scientific computing is hardware portability (CPU vs. GPU). QPhase addresses this through the Backend Abstraction.</p> <ul> <li>Problem: Direct usage of libraries like <code>numpy</code> or <code>torch</code> couples the simulation code to a specific hardware backend.</li> <li>Solution: The framework defines a <code>BackendBase</code> Protocol that specifies a standard interface for tensor operations.</li> <li>Implementation: Concrete implementations (<code>NumpyBackend</code>, <code>TorchBackend</code>) wrap the underlying libraries. The simulation kernel interacts exclusively with the abstract interface (conventionally named <code>xp</code>), allowing the underlying execution engine to be swapped via configuration without code changes.</li> </ul>"},{"location":"dev_guide/architecture/#3-structural-subtyping-protocols","title":"3. Structural Subtyping (Protocols)","text":"<p>QPhase leverages Python's <code>typing.Protocol</code> (PEP 544) for interface definitions rather than Abstract Base Classes (ABCs).</p> <ul> <li>Rationale: This enforces Structural Subtyping (Duck Typing) rather than Nominal Subtyping. A class is considered a valid plugin if it implements the required methods, regardless of its inheritance hierarchy.</li> <li>Benefit: This reduces coupling between user code and the framework core. Researchers can develop plugins without importing framework-specific base classes, simplifying distribution and testing.</li> </ul>"},{"location":"dev_guide/architecture/#4-explicit-dependency-contracts-manifests","title":"4. Explicit Dependency Contracts (Manifests)","text":"<p>To ensure robustness in a loosely coupled system, QPhase employs Explicit Dependency Contracts.</p> <ul> <li>Problem: \"Blind\" dependency injection can lead to runtime errors if an Engine requires a plugin (e.g., a specific Model type) that the user failed to configure.</li> <li>Solution: Engines declare their dependencies statically via an <code>EngineManifest</code>.</li> <li>Mechanism: The <code>Scheduler</code> validates the Job Configuration against the Engine's Manifest before execution begins, ensuring all required plugins are present and correctly typed.</li> </ul>"},{"location":"dev_guide/architecture/#execution-lifecycle","title":"Execution Lifecycle","text":"<p>The execution of a simulation follows a deterministic lifecycle managed by the <code>Scheduler</code>:</p> <ol> <li>Initialization: The CLI entry point initializes the application context and loads the system configuration.</li> <li>Discovery: The Registry scans entry points and local directories to populate the component catalog.</li> <li>Configuration Resolution: Job configurations are loaded, validated against Pydantic schemas, and merged with global defaults.</li> <li>Validation: The Scheduler validates job dependencies against the target Engine's <code>EngineManifest</code>.</li> <li>Job Expansion: Parameter scans are processed, expanding high-level job definitions into a list of atomic execution units (<code>JobConfig</code>).</li> <li>Execution Loop:<ul> <li>Isolation: A unique run directory is provisioned.</li> <li>Snapshotting: The resolved configuration is serialized to <code>config_snapshot.json</code> for reproducibility.</li> <li>Instantiation: The <code>Engine</code> and its dependencies are instantiated via the Registry.</li> <li>Simulation: The Engine's <code>run()</code> method executes the physics loop.</li> <li>Persistence: Results are serialized and flushed to disk.</li> </ul> </li> </ol>"},{"location":"dev_guide/architecture/#directory-structure","title":"Directory Structure","text":"<p>The project follows a monorepo structure managed by <code>uv</code> workspaces.</p>"},{"location":"dev_guide/architecture/#source-code-packages","title":"Source Code (<code>packages/</code>)","text":"<ul> <li><code>qphase/</code>: The Core Framework (Shell).<ul> <li><code>core/</code>: Scheduler, Registry, Configuration, Protocols.</li> <li><code>commands/</code>: CLI implementation.</li> </ul> </li> <li><code>qphase_sde/</code>: Standard Engine.<ul> <li>Implements SDE solvers (Euler-Maruyama, SRK).</li> <li>Contains standard physics models (Kerr Cavity, VdP).</li> </ul> </li> <li><code>qphase_viz/</code>: Visualization Engine.<ul> <li>Handles plotting and data post-processing.</li> </ul> </li> </ul>"},{"location":"dev_guide/architecture/#runtime-artifacts-runs","title":"Runtime Artifacts (<code>runs/</code>)","text":"<p>When simulations are executed, QPhase organizes outputs hierarchically:</p> <pre><code>runs/\n\u251c\u2500\u2500 2025-12-29T10-00-00Z_scan_job_0/   # Job 1 (chi=0.1)\n\u2502   \u251c\u2500\u2500 config_snapshot.json           # Full config for this specific point\n\u2502   \u2514\u2500\u2500 results.h5                     # Simulation data\n\u251c\u2500\u2500 2025-12-29T10-00-05Z_scan_job_1/   # Job 2 (chi=0.2)\n\u2502   \u251c\u2500\u2500 config_snapshot.json\n\u2502   \u2514\u2500\u2500 results.h5\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"dev_guide/backend/","title":"Backend System","text":"<p>The Backend System serves as the computational abstraction layer for QPhase. It addresses the challenge of hardware heterogeneity by providing a unified interface for tensor operations, enabling simulation code to remain agnostic to the underlying computational library (e.g., NumPy, PyTorch, CuPy).</p>"},{"location":"dev_guide/backend/#architectural-objective","title":"Architectural Objective","text":"<p>The primary objective is to decouple the Physical Model from the Computational Implementation. This allows a single model implementation to: 1.  Execute on CPUs for debugging or small-scale simulations (via NumPy). 2.  Execute on GPUs for high-performance parallel simulations (via PyTorch or CuPy). 3.  Support automatic differentiation (via PyTorch/JAX) without code modification.</p>"},{"location":"dev_guide/backend/#the-backend-protocol","title":"The Backend Protocol","text":"<p>The core of this system is the <code>BackendBase</code> Protocol, which defines the contract for all computational backends. It standardizes the API for array creation, linear algebra, random number generation, and common utility functions.</p> <p>Strict Hardware Agnosticism: The protocol is designed to prevent \"host transfers\" (moving data between CPU and GPU) during the simulation loop. All operations, including reshaping and indexing, must be performed via the backend interface.</p> <pre><code>@runtime_checkable\nclass BackendBase(Protocol):\n    \"\"\"Abstract interface for tensor operations.\"\"\"\n\n    # Identification\n    def backend_name(self) -&gt; str: ...\n    def device(self) -&gt; str | None: ...\n\n    # Array Creation\n    def array(self, obj: Any, dtype: Any | None = None) -&gt; Any: ...\n    def zeros(self, shape: tuple[int, ...], dtype: Any) -&gt; Any: ...\n    def arange(self, start: int, stop: int | None = None, step: int = 1, dtype: Any | None = None) -&gt; Any: ...\n\n    # Shape Manipulation\n    def expand_dims(self, x: Any, axis: int) -&gt; Any: ...\n    def repeat(self, x: Any, repeats: int, axis: int | None = None) -&gt; Any: ...\n    def stack(self, arrays: tuple[Any, ...], axis: int = 0) -&gt; Any: ...\n    def concatenate(self, arrays: tuple[Any, ...], axis: int = -1) -&gt; Any: ...\n\n    # Math &amp; Linear Algebra\n    def einsum(self, subscripts: str, *operands: Any) -&gt; Any: ...\n    def cholesky(self, a: Any) -&gt; Any: ...\n    def isnan(self, x: Any) -&gt; Any: ...\n\n    @property\n    def pi(self) -&gt; float: ...\n\n    # Random Number Generation\n    def rng(self, seed: int | None) -&gt; Any: ...\n    def randn(self, rng: Any, shape: tuple[int, ...], dtype: Any) -&gt; Any: ...\n</code></pre>"},{"location":"dev_guide/backend/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"dev_guide/backend/#wrapper-pattern","title":"Wrapper Pattern","text":"<p>Concrete backends (e.g., <code>NumpyBackend</code>, <code>TorchBackend</code>) implement the <code>BackendBase</code> protocol by wrapping the respective library calls. This ensures that method signatures (arguments, return types) are consistent across all implementations, smoothing over API differences between libraries (e.g., <code>np.concatenate</code> vs <code>torch.cat</code>, <code>np.repeat</code> vs <code>torch.repeat_interleave</code>).</p>"},{"location":"dev_guide/backend/#tensor-dispatching","title":"Tensor Dispatching","text":"<p>In the simulation kernel, the backend instance is typically injected as <code>self.xp</code> (following the array API standard convention). All mathematical operations are dispatched through this instance.</p> <p>Example: <pre><code># Hardware-agnostic implementation\ndef drift(self, state):\n    # self.xp could be numpy or torch\n    # Using self.xp.pi ensures we use the correct scalar type if needed\n    phase = 2.0 * self.xp.pi * state\n    return -1j * self.xp.einsum(\"ij,j-&gt;i\", self.hamiltonian, phase)\n</code></pre></p>"},{"location":"dev_guide/backend/#available-backends","title":"Available Backends","text":""},{"location":"dev_guide/backend/#1-numpy-backend-backend-numpy","title":"1. NumPy Backend (<code>backend: numpy</code>)","text":"<ul> <li>Target: CPU.</li> <li>Use Case: Development, debugging, small-scale simulations.</li> <li>Characteristics: Double precision by default, deterministic execution, broad compatibility.</li> </ul>"},{"location":"dev_guide/backend/#2-pytorch-backend-backend-torch","title":"2. PyTorch Backend (<code>backend: torch</code>)","text":"<ul> <li>Target: CPU / GPU (CUDA/MPS).</li> <li>Use Case: Large-scale parallel simulations, gradient-based optimization.</li> <li>Characteristics: Supports <code>float32</code>/<code>float64</code>, automatic device management, batched operations. Implements <code>repeat</code> using <code>torch.repeat_interleave</code>.</li> </ul>"},{"location":"dev_guide/backend/#3-cupy-backend-backend-cupy","title":"3. CuPy Backend (<code>backend: cupy</code>)","text":"<ul> <li>Target: NVIDIA GPU.</li> <li>Use Case: High-performance computing where PyTorch overhead is undesirable.</li> <li>Characteristics: NumPy-compatible API on GPU.</li> </ul>"},{"location":"dev_guide/backend/#extending-the-backend","title":"Extending the Backend","text":"<p>Developers can introduce support for new libraries (e.g., JAX, TensorFlow) by implementing a class that satisfies the <code>BackendBase</code> protocol and registering it under the <code>backend</code> namespace.</p>"},{"location":"dev_guide/cli/","title":"CLI Architecture","text":"<p>The Command Line Interface (CLI) serves as the primary entry point for user interaction. It is built upon the Typer library, which leverages Python type hints to generate command-line parsers and help documentation automatically.</p>"},{"location":"dev_guide/cli/#command-structure","title":"Command Structure","text":"<p>The CLI is organized into a hierarchical command group structure, rooted at the <code>qps</code> entry point.</p> <ul> <li><code>qps</code> (Root)<ul> <li><code>init</code>: Project bootstrapping.</li> <li><code>run</code>: Simulation execution.</li> <li><code>list</code>: Plugin discovery and listing.</li> <li><code>show</code>: Plugin introspection.</li> <li><code>template</code>: Configuration scaffolding.</li> </ul> </li> </ul>"},{"location":"dev_guide/cli/#implementation-details","title":"Implementation Details","text":""},{"location":"dev_guide/cli/#entry-point","title":"Entry Point","text":"<p>The main application entry point is defined in <code>qphase.main:app</code>. This <code>Typer</code> instance aggregates sub-commands and handles global flags (e.g., <code>--verbose</code>, <code>--version</code>).</p>"},{"location":"dev_guide/cli/#command-registration","title":"Command Registration","text":"<p>Commands are registered using the <code>@app.command()</code> decorator. Typer inspects the function signature to determine argument types and options.</p> <pre><code>@app.command()\ndef jobs(\n    job_name: str = typer.Argument(..., help=\"Job name\"),\n    verbose: bool = typer.Option(False, \"--verbose\", \"-v\"),\n):\n    \"\"\"Execute a simulation job.\"\"\"\n    # ... implementation ...\n</code></pre>"},{"location":"dev_guide/cli/#extensibility","title":"Extensibility","text":"<p>While the core commands are hardcoded, the CLI architecture allows for future extensibility. The Registry System includes a <code>command</code> namespace, which is reserved for dynamically loading additional CLI sub-commands from plugins. This will allow third-party packages to extend the <code>qps</code> tool with custom functionality (e.g., <code>qps plot</code>, <code>qps analyze</code>).</p>"},{"location":"dev_guide/cli/#integration-with-scheduler","title":"Integration with Scheduler","text":"<p>The CLI acts as a thin client for the <code>Scheduler</code>. When <code>qps run</code> is invoked: 1.  It parses the command line arguments. 2.  It loads the <code>SystemConfig</code>. 3.  It instantiates the <code>Scheduler</code>. 4.  It delegates the execution to <code>scheduler.run()</code>.</p> <p>This separation ensures that the core execution logic is not coupled to the CLI interface, allowing simulations to be triggered programmatically (e.g., from a Jupyter notebook) if needed.</p>"},{"location":"dev_guide/configuration/","title":"Configuration System","text":"<p>The Configuration System is responsible for parsing, validating, and merging simulation parameters. It employs a hierarchical loading strategy and leverages Pydantic for strict schema validation.</p>"},{"location":"dev_guide/configuration/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p>The system constructs the final execution context by merging configuration data from three distinct layers, in increasing order of precedence:</p> <ol> <li>System Defaults: Hardcoded defaults within the package and plugin definitions.</li> <li>Global Configuration (<code>configs/global.yaml</code>): User-defined project-wide settings (e.g., default backend, logging verbosity).</li> <li>Job Configuration (<code>configs/jobs/*.yaml</code>): Experiment-specific parameters.</li> </ol>"},{"location":"dev_guide/configuration/#the-loading-pipeline","title":"The Loading Pipeline","text":"<p>The configuration loading process follows a strict pipeline:</p> <ol> <li>File I/O: The YAML file is read and parsed into a raw Python dictionary.</li> <li>Structure Normalization: The raw dictionary is normalized to ensure consistent structure (e.g., handling shorthand notations).</li> <li>Plugin Extraction: The system identifies keys that correspond to registered plugin namespaces (e.g., <code>backend</code>, <code>model</code>).</li> <li>Schema Validation:<ul> <li>The core job structure is validated against the <code>JobConfig</code> model.</li> <li>Each plugin configuration block is validated against its respective <code>config_schema</code> defined by the plugin class.</li> </ul> </li> <li>Merging: Global defaults are merged into the job configuration, filling in missing optional fields.</li> </ol>"},{"location":"dev_guide/configuration/#schema-validation-with-pydantic","title":"Schema Validation with Pydantic","text":"<p>QPhase uses Pydantic v2 to enforce type safety and data integrity.</p>"},{"location":"dev_guide/configuration/#jobconfig-model","title":"<code>JobConfig</code> Model","text":"<p>The <code>JobConfig</code> model defines the structural skeleton of a simulation job.</p> <pre><code>class JobConfig(BaseModel):\n    name: str\n    engine: dict[str, Any]\n    plugins: dict[str, dict[str, Any]]\n    params: dict[str, Any]\n    # ...\n</code></pre>"},{"location":"dev_guide/configuration/#plugin-schemas","title":"Plugin Schemas","text":"<p>Each plugin must define a <code>config_schema</code> class variable pointing to a Pydantic model. This allows the Registry to validate plugin-specific parameters before the plugin is instantiated.</p> <p>Example: <pre><code>class KerrCavityConfig(BaseModel):\n    chi: float = Field(..., gt=0, description=\"Nonlinearity\")\n    detuning: float = Field(0.0, description=\"Frequency detuning\")\n</code></pre></p> <p>If a user provides a string for <code>chi</code> or a negative value, the Pydantic validator will raise a descriptive error during the loading phase, preventing runtime failures deep in the simulation loop.</p>"},{"location":"dev_guide/configuration/#parameter-scanning-support","title":"Parameter Scanning Support","text":"<p>The configuration system includes metadata support for parameter scanning. Fields in Pydantic models can be marked as <code>scanable</code> via <code>json_schema_extra</code>.</p> <pre><code>class SDEConfig(BaseModel):\n    dt: float = Field(..., json_schema_extra={\"scanable\": True})\n</code></pre> <p>The <code>JobExpander</code> uses this metadata to determine which fields are eligible for expansion when a list of values is provided in the YAML configuration.</p>"},{"location":"dev_guide/error_handling/","title":"Error Handling Strategy","text":"<p>QPhase implements a structured error handling strategy designed to provide clear, actionable feedback to users while maintaining robust execution control for the scheduler.</p>"},{"location":"dev_guide/error_handling/#exception-hierarchy","title":"Exception Hierarchy","text":"<p>All framework-specific exceptions inherit from a common base class, <code>QPhaseError</code>. This allows the top-level CLI wrapper to catch known errors and display clean messages without printing stack traces (unless verbose mode is enabled).</p> <pre><code>class QPhaseError(Exception):\n    \"\"\"Base class for all QPhase exceptions.\"\"\"\n\nclass QPhaseConfigError(QPhaseError):\n    \"\"\"Raised when configuration validation fails.\"\"\"\n\nclass QPhasePluginError(QPhaseError):\n    \"\"\"Raised when plugin loading or instantiation fails.\"\"\"\n\nclass QPhaseRuntimeError(QPhaseError):\n    \"\"\"Raised during simulation execution.\"\"\"\n\nclass QPhaseIOError(QPhaseError):\n    \"\"\"Raised during file input/output operations.\"\"\"\n</code></pre>"},{"location":"dev_guide/error_handling/#error-propagation","title":"Error Propagation","text":"<ol> <li>Validation Phase: Errors during configuration loading (e.g., missing fields, invalid types) are caught early and raised as <code>QPhaseConfigError</code>. The CLI displays the specific validation message from Pydantic.</li> <li>Dependency Check: If a job is missing required plugins (as defined in <code>EngineManifest</code>), a <code>QPhaseConfigError</code> is raised before execution begins.</li> <li>Execution Phase: Exceptions occurring within a job (e.g., numerical instability, runtime assertions) are caught by the <code>Scheduler</code>.<ul> <li>The exception is logged.</li> <li>The job is marked as <code>failed</code> in the <code>JobResult</code>.</li> <li>The scheduler proceeds to the next independent job (unless <code>fail_fast</code> is enabled).</li> </ul> </li> </ol>"},{"location":"dev_guide/error_handling/#logging","title":"Logging","text":"<p>QPhase uses the standard Python <code>logging</code> module. *   Console: By default, only <code>INFO</code> level and above are shown. *   File: If configured, all logs (including <code>DEBUG</code>) are written to a log file. *   Format: Logs include timestamps and module names to aid in debugging.</p>"},{"location":"dev_guide/faq/","title":"Developer FAQ","text":"<p>This guide addresses common questions and issues encountered when developing plugins for QPhase.</p>"},{"location":"dev_guide/faq/#plugin-development","title":"Plugin Development","text":""},{"location":"dev_guide/faq/#why-is-my-plugin-not-showing-up-in-qps-list","title":"Why is my plugin not showing up in <code>qps list</code>?","text":"<p>If your plugin is not appearing in the registry, check the following:</p> <ol> <li>Entry Point Configuration: Ensure your <code>pyproject.toml</code> has the correct entry point group <code>[project.entry-points.qphase]</code>.</li> <li>Installation: Did you install your package? If you are developing locally, use <code>pip install -e .</code> to install in editable mode.</li> <li>Namespace: Ensure your entry point key follows the <code>namespace.name</code> format (e.g., <code>\"backend.my_backend\"</code>).</li> <li>Cache: QPhase caches entry points. Try reinstalling your package to refresh the metadata.</li> </ol>"},{"location":"dev_guide/faq/#how-do-i-handle-optional-dependencies","title":"How do I handle optional dependencies?","text":"<p>If your plugin requires a heavy library (like <code>torch</code> or <code>cupy</code>) that shouldn't be a hard dependency for QPhase, follow these steps:</p> <ol> <li>Use Lazy Registration: Register your plugin using a dotted path string so the module isn't imported at startup.</li> <li>Import Inside Methods: Import the heavy library inside your <code>__init__</code> or <code>run</code> method, not at the top level of your module.</li> <li>Fail Gracefully: Raise a clear <code>ImportError</code> if the dependency is missing.</li> </ol> <pre><code>class MyHeavyPlugin:\n    def __init__(self, config):\n        try:\n            import torch\n        except ImportError:\n            raise ImportError(\"This plugin requires 'torch'. Please install it.\")\n</code></pre>"},{"location":"dev_guide/faq/#why-is-my-configuration-validation-failing","title":"Why is my configuration validation failing?","text":"<p>QPhase uses Pydantic for validation. Common issues include:</p> <ul> <li>Type Mismatch: Passing a string <code>\"1e-3\"</code> to a <code>float</code> field. Pydantic usually coerces this, but strict mode might fail.</li> <li>Missing Fields: A required field (no default value) is missing from the YAML.</li> <li>Extra Fields: Your YAML has fields not defined in the schema. Set <code>model_config = ConfigDict(extra=\"allow\")</code> if you want to permit this.</li> </ul>"},{"location":"dev_guide/faq/#why-does-my-engine-fail-with-missing-required-plugins","title":"Why does my Engine fail with \"missing required plugins\"?","text":"<p>This error comes from the <code>EngineManifest</code> validation. Your Engine class likely declares a <code>manifest</code> with <code>required_plugins={\"model\", ...}</code>. If the user's Job Configuration does not provide a <code>model</code> plugin in the <code>plugins</code> section, the Scheduler will block execution.</p> <p>Fix: Ensure your YAML configuration includes all plugins listed in the Engine's <code>required_plugins</code>.</p>"},{"location":"dev_guide/faq/#architecture-internals","title":"Architecture &amp; Internals","text":""},{"location":"dev_guide/faq/#what-is-the-difference-between-eager-and-lazy-registration","title":"What is the difference between Eager and Lazy registration?","text":"<ul> <li>Eager (<code>register</code>): You pass the class object directly. The class is imported immediately when the registry is initialized. This is good for core plugins but bad for startup time.</li> <li>Lazy (<code>register_lazy</code>): You pass a string path (<code>\"pkg.mod:Class\"</code>). The class is only imported when someone calls <code>registry.create()</code> or asks for its schema. This is the recommended way for most plugins.</li> </ul>"},{"location":"dev_guide/faq/#how-does-the-registry-find-plugins","title":"How does the Registry find plugins?","text":"<p>The Registry uses Python's standard <code>importlib.metadata</code> to scan for entry points in the <code>qphase</code> group. It does this once at startup. It also scans directories defined in <code>SystemConfig.paths.plugin_dirs</code> for <code>.qphase_plugins.yaml</code> files to support local, non-installed plugins.</p>"},{"location":"dev_guide/faq/#can-i-override-a-core-plugin","title":"Can I override a core plugin?","text":"<p>Yes. If you register a plugin with the same namespace and name as an existing one (e.g., <code>backend.numpy</code>), and set <code>overwrite=True</code> (or use a higher priority loading mechanism), your plugin will replace the core one. This allows for powerful customization but should be done with caution.</p>"},{"location":"dev_guide/plugin_development/","title":"Plugin Development Guide","text":"<p>This guide outlines the procedure for developing extensions (plugins) for the QPhase framework. The most common extension point is the Model, which defines the physical system to be simulated.</p>"},{"location":"dev_guide/plugin_development/#the-plugin-contract","title":"The Plugin Contract","text":"<p>QPhase utilizes Structural Subtyping (Duck Typing). A class is recognized as a valid plugin if it satisfies the interface contract defined by the corresponding Protocol (e.g., <code>PluginBase</code>, <code>ModelBase</code>). Inheritance from framework base classes is optional but not required.</p> <p>To implement a plugin, three components are necessary: 1.  Configuration Schema: A Pydantic model defining the parameters. 2.  Implementation Class: The class containing the logic. 3.  Registration: An entry in the plugin registry.</p>"},{"location":"dev_guide/plugin_development/#1-defining-the-configuration-schema","title":"1. Defining the Configuration Schema","text":"<p>Parameters are defined using Pydantic models. This ensures strict type validation and automatic documentation generation.</p> <pre><code>from pydantic import BaseModel, Field\n\nclass MyModelConfig(BaseModel):\n    \"\"\"Configuration schema for MyModel.\"\"\"\n\n    # Required parameter (no default)\n    chi: float = Field(..., description=\"Nonlinearity strength\")\n\n    # Optional parameter with default\n    kappa: float = Field(1.0, gt=0, description=\"Decay rate (must be positive)\")\n</code></pre>"},{"location":"dev_guide/plugin_development/#2-implementing-the-logic","title":"2. Implementing the Logic","text":"<p>The implementation class must accept the configuration object and a backend instance in its constructor.</p> <p>Critical Requirement: All mathematical operations must be performed using the injected <code>backend</code> instance (conventionally <code>self.xp</code>). Direct usage of <code>numpy</code> or <code>torch</code> breaks hardware agnosticism.</p>"},{"location":"dev_guide/plugin_development/#example-sde-model-implementation","title":"Example: SDE Model Implementation","text":"<p>An SDE model typically implements <code>drift</code> and <code>diffusion</code> methods.</p> <pre><code>from typing import Any, ClassVar\nfrom qphase.backend.xputil import get_xp\n\nclass MyModel:\n    # Metadata for the Registry\n    name: ClassVar[str] = \"my_model\"\n    description: ClassVar[str] = \"Kerr oscillator with additive noise\"\n    config_schema: ClassVar[type] = MyModelConfig\n\n    def __init__(self, config: MyModelConfig, **kwargs: Any):\n        self.cfg = config\n        # Backend is inferred from data in drift/diffusion\n\n    def drift(self, state: Any, t: float, params: dict) -&gt; Any:\n        \"\"\"\n        Calculate the deterministic drift vector: A(X, t)\n        dx = A(X, t)dt + B(X, t)dW\n        \"\"\"\n        xp = get_xp(state)\n        x = state\n        chi = self.cfg.chi\n        kappa = self.cfg.kappa\n\n        # Use xp for tensor operations\n        # -1j * chi * |x|^2 * x - kappa * x\n        term1 = -1j * chi * (xp.abs(x)**2) * x\n        term2 = -kappa * x\n        return term1 + term2\n\n    def diffusion(self, state: Any, t: float, params: dict) -&gt; Any:\n        \"\"\"\n        Calculate the diffusion matrix: B(X, t)\n        \"\"\"\n        xp = get_xp(state)\n        # Additive noise: returns a scalar or constant tensor\n        return xp.sqrt(self.cfg.kappa)\n</code></pre>"},{"location":"dev_guide/plugin_development/#example-analyser-implementation","title":"Example: Analyser Implementation","text":"<p>Analysers process the raw simulation results.</p> <pre><code>from typing import Any, ClassVar\nfrom qphase.backend.base import BackendBase\nfrom qphase.core.protocols import ResultProtocol\nfrom qphase_sde.result import SDEResult\n\nclass MyAnalyser:\n    name: ClassVar[str] = \"my_analyser\"\n    description: ClassVar[str] = \"Calculates mean photon number\"\n    config_schema: ClassVar[type] = MyAnalyserConfig\n\n    def __init__(self, config: MyAnalyserConfig, **kwargs: Any):\n        self.cfg = config\n\n    def analyze(self, data: Any, backend: BackendBase) -&gt; ResultProtocol:\n        \"\"\"\n        Process the simulation result.\n        \"\"\"\n        # Example: Calculate mean of trajectory\n        # data is expected to be a tensor or TrajectorySet\n        if hasattr(data, \"data\"):\n            traj = data.data\n        else:\n            traj = data\n\n        mean_val = backend.mean(traj, axis=0)\n        result_data = backend.abs(mean_val)**2\n\n        return SDEResult(trajectory=result_data, kind=\"trajectory\")\n</code></pre>"},{"location":"dev_guide/plugin_development/#example-engine-implementation-with-manifest","title":"Example: Engine Implementation with Manifest","text":"<p>Engines orchestrate the simulation. They must declare their dependencies using <code>EngineManifest</code>.</p> <pre><code>from typing import ClassVar\nfrom qphase.core.protocols import EngineManifest\n\nclass MyEngine:\n    name: ClassVar[str] = \"my_engine\"\n    description: ClassVar[str] = \"Custom simulation engine\"\n    config_schema: ClassVar[type] = MyEngineConfig\n\n    # Declare dependencies\n    manifest: ClassVar[EngineManifest] = EngineManifest(\n        required_plugins={\"model\", \"backend\"},\n        optional_plugins={\"analyser\"}\n    )\n\n    def __init__(self, config: MyEngineConfig, plugins: dict):\n        self.cfg = config\n        self.model = plugins[\"model\"]\n        self.backend = plugins[\"backend\"]\n        # Handle optional plugin\n        self.analyser = plugins.get(\"analyser\")\n\n    def run(self):\n        # ... simulation loop ...\n        pass\n</code></pre>"},{"location":"dev_guide/plugin_development/#3-registration","title":"3. Registration","text":"<p>Plugins can be registered via two mechanisms:</p>"},{"location":"dev_guide/plugin_development/#a-local-registration-development","title":"A. Local Registration (Development)","text":"<p>Create a <code>.qphase_plugins.yaml</code> file in your project root. This maps the plugin namespace and name to the Python class path.</p> <pre><code>model.my_model: \"plugins.my_physics:MyModel\"\nanalyser.my_analyser: \"plugins.my_analysis:MyAnalyser\"\n</code></pre>"},{"location":"dev_guide/plugin_development/#b-package-registration-distribution","title":"B. Package Registration (Distribution)","text":"<p>If distributing the plugin as a Python package, use standard entry points in <code>pyproject.toml</code>.</p> <pre><code>[project.entry-points.qphase]\n\"model.my_model\" = \"my_package.models:MyModel\"\n\"analyser.my_analyser\" = \"my_package.analysis:MyAnalyser\"\n</code></pre>"},{"location":"dev_guide/protocols/","title":"Protocol System","text":"<p>QPhase utilizes Python Protocols (introduced in PEP 544) to define the interfaces between the core framework and its extensible components. This design choice favors Structural Subtyping (Duck Typing) over the traditional Nominal Subtyping enforced by Abstract Base Classes (ABCs).</p>"},{"location":"dev_guide/protocols/#structural-vs-nominal-subtyping","title":"Structural vs. Nominal Subtyping","text":""},{"location":"dev_guide/protocols/#nominal-subtyping-abcs","title":"Nominal Subtyping (ABCs)","text":"<p>In a nominal system, a class is a subtype of another only if it explicitly inherits from it. *   Requirement: <code>class MyPlugin(PluginBase): ...</code> *   Drawback: This creates a hard dependency on the framework code. Third-party plugins must import the base class, leading to potential version conflicts and tighter coupling.</p>"},{"location":"dev_guide/protocols/#structural-subtyping-protocols","title":"Structural Subtyping (Protocols)","text":"<p>In a structural system, a class is a subtype if it implements the required methods and attributes, regardless of inheritance. *   Requirement: The class simply needs to have the correct methods. *   Advantage: Decoupling. A plugin can be developed, tested, and distributed without importing <code>qphase</code> at runtime. The dependency is only on the interface contract, not the implementation.</p>"},{"location":"dev_guide/protocols/#core-protocols","title":"Core Protocols","text":"<p>The framework defines several key protocols that plugins must satisfy.</p>"},{"location":"dev_guide/protocols/#1-pluginbase","title":"1. <code>PluginBase</code>","text":"<p>The fundamental contract for all discoverable components.</p> <pre><code>@runtime_checkable\nclass PluginBase(Protocol):\n    \"\"\"The minimal contract for any QPhase plugin.\"\"\"\n\n    # Metadata (Class Variables)\n    name: ClassVar[str]                 # Unique identifier\n    description: ClassVar[str]          # Human-readable description\n    config_schema: ClassVar[type[Any]]  # Pydantic model for configuration\n\n    def __init__(self, config: Any | None = None, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Initialize the plugin.\n\n        Args:\n            config: A validated configuration object (instance of config_schema).\n            **kwargs: Additional dependencies injected by the Registry.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"dev_guide/protocols/#2-enginebase-enginemanifest","title":"2. <code>EngineBase</code> &amp; <code>EngineManifest</code>","text":"<p>The contract for simulation engines. Engines must declare their dependencies via a manifest.</p> <pre><code>@dataclass\nclass EngineManifest:\n    \"\"\"\n    Declares the dependencies of an Engine.\n    \"\"\"\n    required_plugins: set[str] = field(default_factory=set)\n    optional_plugins: set[str] = field(default_factory=set)\n    defaults: dict[str, str] = field(default_factory=dict)\n\n@runtime_checkable\nclass EngineBase(PluginBase, Protocol):\n    # Manifest declaring dependencies\n    manifest: ClassVar[EngineManifest] = EngineManifest()\n\n    def run(\n        self,\n        data: Any | None = None,\n        *,\n        progress_cb: Callable[[float | None, float | None, str, str | None], None]\n        | None = None,\n    ) -&gt; ResultProtocol:\n        \"\"\"Execute the simulation and return a result object.\"\"\"\n        ...\n</code></pre>"},{"location":"dev_guide/protocols/#3-backendbase","title":"3. <code>BackendBase</code>","text":"<p>The contract for computational backends (see Backend System).</p>"},{"location":"dev_guide/protocols/#runtime-verification","title":"Runtime Verification","text":"<p>While Protocols are primarily a static analysis tool (used by MyPy/Pyright), QPhase utilizes the <code>@runtime_checkable</code> decorator to perform runtime validation during plugin instantiation. This allows the Registry to raise informative errors if a loaded plugin fails to satisfy the required contract.</p>"},{"location":"dev_guide/registry/","title":"Registry System","text":"<p>The Registry System functions as the central service locator and dependency injection container for QPhase. It manages the lifecycle of all extensible components, providing a unified mechanism for registration, discovery, and instantiation.</p>"},{"location":"dev_guide/registry/#core-architecture","title":"Core Architecture","text":"<p>The registry is implemented as a singleton <code>RegistryCenter</code> that maintains a hierarchical lookup table: <code>Namespace -&gt; Name -&gt; Entry</code>.</p>"},{"location":"dev_guide/registry/#namespaces","title":"Namespaces","text":"<p>To ensure modularity and prevent naming collisions, plugins are segregated into namespaces. Standard namespaces include:</p> Namespace Description Example <code>backend</code> Computational backends <code>numpy</code>, <code>torch</code> <code>engine</code> Simulation engines <code>sde</code>, <code>viz</code> <code>model</code> Physical models <code>kerr_cavity</code>, <code>vdp</code> <code>integrator</code> Numerical integrators <code>euler_maruyama</code>, <code>srk</code> <code>analyser</code> Result analysis tools <code>mean_photon</code>, <code>wigner</code>"},{"location":"dev_guide/registry/#entry-management-strategy","title":"Entry Management Strategy","text":"<p>The registry employs a dual-strategy for entry management to balance startup latency with runtime flexibility:</p> <ol> <li> <p>Eager Entries (Callable):</p> <ul> <li>Mechanism: The plugin class or factory function is imported and stored directly in memory during initialization.</li> <li>Application: Used for core plugins and testing scenarios where immediate availability is required.</li> </ul> </li> <li> <p>Lazy Entries (Dotted Path):</p> <ul> <li>Mechanism: The registry stores a string reference (e.g., <code>\"pkg.module:ClassName\"</code>). The actual module import is deferred until the first request for instantiation.</li> <li>Application: Used for third-party plugins and optional dependencies. This minimizes the application's startup time and memory footprint.</li> </ul> </li> </ol>"},{"location":"dev_guide/registry/#discovery-mechanisms","title":"Discovery Mechanisms","text":"<p>QPhase supports two primary discovery mechanisms:</p>"},{"location":"dev_guide/registry/#1-entry-points-package-based","title":"1. Entry Points (Package-based)","text":"<p>For distributable Python packages, QPhase utilizes the standard <code>entry_points</code> mechanism (defined in <code>pyproject.toml</code>). The registry scans the <code>qphase</code> group at startup.</p> <pre><code>[project.entry-points.qphase]\n\"model.my_model\" = \"my_package.models:MyModel\"\n</code></pre>"},{"location":"dev_guide/registry/#2-local-configuration-development-based","title":"2. Local Configuration (Development-based)","text":"<p>For local development and ad-hoc extensions, the registry parses a <code>.qphase_plugins.yaml</code> file located in the project root. This allows researchers to register scripts without packaging them.</p> <pre><code>model.custom_hamiltonian: \"plugins.physics:Hamiltonian\"\n</code></pre>"},{"location":"dev_guide/registry/#instantiation-factory","title":"Instantiation Factory","text":"<p>The <code>create()</code> method serves as the universal factory for all components. It handles: 1.  Resolution: Looking up the entry by namespace and name. 2.  Loading: Importing the module if it is a lazy entry. 3.  Validation: Validating the provided configuration dictionary against the plugin's <code>config_schema</code> (Pydantic model). 4.  Injection: Instantiating the class with the validated configuration and any additional dependencies (e.g., injecting the <code>backend</code> instance into a <code>model</code>).</p> <pre><code># Example: Instantiating a model with dependency injection\nmodel = registry.create(\n    \"model:kerr_cavity\",\n    config={\"chi\": 1.0},\n    backend=numpy_backend_instance\n)\n</code></pre>"},{"location":"dev_guide/registry/#dependency-resolution","title":"Dependency Resolution","text":"<p>While the Registry provides the mechanism to create plugins, the Scheduler acts as the orchestrator. It uses the <code>EngineManifest</code> of the selected Engine to determine which plugins to request from the Registry.</p>"},{"location":"dev_guide/scheduler/","title":"Scheduler System","text":"<p>The Scheduler is the execution orchestration layer of QPhase. It is responsible for translating high-level job definitions into concrete computational tasks, managing their lifecycle, and ensuring data integrity.</p>"},{"location":"dev_guide/scheduler/#functional-responsibilities","title":"Functional Responsibilities","text":"<ol> <li>Job Expansion: Transforming abstract job configurations (which may contain parameter ranges) into a linear sequence of atomic tasks.</li> <li>Dependency Resolution: Analyzing the execution graph to ensure jobs are executed in topological order (e.g., ensuring input data exists before a dependent job starts).</li> <li>Context Management: Provisioning isolated execution environments (directories) for each job to prevent data contamination.</li> <li>Error Handling: Intercepting runtime exceptions to prevent batch failures (i.e., a single failed job should not terminate the entire campaign).</li> </ol>"},{"location":"dev_guide/scheduler/#dependency-validation","title":"Dependency Validation","text":"<p>The Scheduler enforces explicit dependency contracts declared by Engines via the <code>EngineManifest</code>.</p> <ol> <li>Manifest Declaration: Each Engine declares its required and optional plugins.     <pre><code>class MyEngine(EngineBase):\n    manifest = EngineManifest(\n        required_plugins={\"backend\", \"model\"},\n        optional_plugins={\"analyser\"}\n    )\n</code></pre></li> <li>Pre-flight Check: Before any job is executed, the Scheduler validates that the job configuration provides all <code>required_plugins</code> declared by the target Engine. This prevents runtime failures due to missing dependencies.</li> </ol>"},{"location":"dev_guide/scheduler/#plugin-instantiation","title":"Plugin Instantiation","text":"<p>For each job, the Scheduler performs the following steps to instantiate the environment:</p> <ol> <li>Engine Resolution: The <code>engine</code> plugin is instantiated first.</li> <li>Manifest Inspection: The Scheduler reads <code>engine.manifest</code>.</li> <li>Dependency Injection: The Scheduler iterates through <code>required_plugins</code> and <code>optional_plugins</code>.<ul> <li>It looks up the corresponding configuration in the Job Config.</li> <li>It calls <code>registry.create()</code> for each plugin.</li> <li>It collects these instances into a dictionary.</li> </ul> </li> <li>Engine Execution: Finally, the Engine is initialized with the dictionary of instantiated plugins and the simulation is launched.</li> </ol>"},{"location":"dev_guide/scheduler/#the-execution-graph","title":"The Execution Graph","text":"<p>While the current implementation primarily supports serial execution, the underlying data structure (<code>JobList</code>) is designed as a directed acyclic graph (DAG).</p>"},{"location":"dev_guide/scheduler/#jobresult-encapsulation","title":"JobResult Encapsulation","text":"<p>The outcome of every execution is encapsulated in a <code>JobResult</code> object, which serves as the contract between the Scheduler and the reporting system.</p> <pre><code>@dataclass\nclass JobResult:\n    job_index: int           # Topological index\n    job_name: str            # Unique identifier\n    run_dir: Path            # Isolated output directory\n    run_id: str              # Timestamped UUID\n    success: bool            # Execution status\n    error: str | None = None # Exception trace if failed\n</code></pre>"},{"location":"dev_guide/scheduler/#parameter-scanning-logic","title":"Parameter Scanning Logic","text":"<p>The Scheduler integrates with the <code>JobExpander</code> to support parameter sweeps. This process transforms a single \"Job Definition\" (which may contain lists of values) into multiple atomic \"Job Configurations\".</p>"},{"location":"dev_guide/scheduler/#detection-mechanism","title":"Detection Mechanism","text":"<p>The <code>JobExpander</code> inspects the configuration dictionary for lists. *   Scanable Parameters: By default, any list found in a plugin configuration (e.g., <code>model.chi: [0.1, 0.2, 0.3]</code>) is treated as a parameter to be scanned. *   Non-Scanable Lists: To pass a list as a literal value (e.g., a vector <code>[1, 0, 0]</code>), the plugin must explicitly mark that field as non-scanable in its schema, or the user must wrap it (implementation dependent, currently all lists are candidates for expansion if the plugin registers them as scanable).</p>"},{"location":"dev_guide/scheduler/#expansion-strategies","title":"Expansion Strategies","text":"<ol> <li> <p>Cartesian Product (Default):</p> <ul> <li>If multiple parameters are lists, QPhase generates every possible combination.</li> <li>Example: <code>A=[1, 2]</code>, <code>B=[3, 4]</code> -&gt; <code>(1,3), (1,4), (2,3), (2,4)</code>.</li> <li>Result: 4 separate Jobs.</li> </ul> </li> <li> <p>Zipped Expansion:</p> <ul> <li>Iterates over parameters in lockstep. Requires all lists to have the same length.</li> <li>Example: <code>A=[1, 2]</code>, <code>B=[3, 4]</code> -&gt; <code>(1,3), (2,4)</code>.</li> <li>Result: 2 separate Jobs.</li> </ul> </li> </ol>"},{"location":"dev_guide/scheduler/#runtime-isolation-session-management","title":"Runtime Isolation &amp; Session Management","text":"<p>QPhase uses a Session-Based I/O strategy to manage execution contexts.</p>"},{"location":"dev_guide/scheduler/#session-structure","title":"Session Structure","text":"<p>Every execution command (e.g., <code>qps run ...</code>) initiates a new Session. A session acts as a container for all jobs executed in that command, providing a shared context for data exchange and logging.</p> <p>Directory Layout: <pre><code>runs/\n  2025-12-31T10-00-00_a1b2c3/      &lt;-- Session Root (Timestamp + Short UUID)\n    \u251c\u2500\u2500 session_manifest.json      &lt;-- Session Metadata &amp; State\n    \u251c\u2500\u2500 job_01_sde/                &lt;-- Job Directory\n    \u2502     \u251c\u2500\u2500 config_snapshot.json\n    \u2502     \u2514\u2500\u2500 result.h5\n    \u2514\u2500\u2500 job_02_viz/                &lt;-- Job Directory\n          \u251c\u2500\u2500 config_snapshot.json\n          \u2514\u2500\u2500 plot.png\n</code></pre></p>"},{"location":"dev_guide/scheduler/#session-manifest","title":"Session Manifest","text":"<p>The <code>session_manifest.json</code> file serves as the \"brain\" of the session, recording: - Session ID: Unique identifier. - Status: Global status (running, completed, failed). - Job Registry: A map of all jobs, their status, output paths, and dependencies.</p> <p>This manifest enables downstream features like Resume Capability (restarting failed jobs) and DAG Visualization.</p>"},{"location":"dev_guide/scheduler/#job-isolation","title":"Job Isolation","text":"<p>Within a session, each job runs in its own subdirectory (<code>session_dir / job_name</code>). *   Concurrency Safety: Jobs write to exclusive paths. *   Traceability: Each directory contains a <code>config_snapshot.json</code> that records the exact scalar values used for that specific run.</p>"},{"location":"user_guide/","title":"User Guide","text":"<p>Welcome to the QPhase User Guide! This section contains everything you need to know to get started with QPhase, from installation to running your first simulations.</p>"},{"location":"user_guide/#getting-started","title":"Getting Started","text":"<ul> <li>Quick Start Guide: Learn how to install QPhase and run your first simulation</li> <li>Installation: Detailed installation instructions for different environments</li> <li>Configuration: How to configure QPhase using YAML files</li> <li>SDE Simulation: Guide to Stochastic Differential Equation simulations</li> <li>CLI Reference: Complete command-line interface documentation</li> </ul>"},{"location":"user_guide/#core-concepts","title":"Core Concepts","text":"<p>Learn the fundamental concepts of QPhase: - Configuration files and parameter management - Backend selection (CPU/GPU) - Parameter sweeps and batch processing - Result saving and reproducibility</p> <p>Choose a guide below to get started!</p>"},{"location":"user_guide/cli/","title":"CLI Reference","text":"<p>The <code>qps</code> (QPhase Shell) command-line interface is the primary tool for interacting with the QPhase framework. It facilitates project initialization, job execution, plugin management, and configuration generation.</p>"},{"location":"user_guide/cli/#global-options","title":"Global Options","text":"<p>All commands support the following global flags:</p> <ul> <li><code>--help</code>: Display the help message and exit.</li> <li><code>--version</code>: Display the installed version number.</li> <li><code>--verbose</code> / <code>-v</code>: Enable verbose debug logging.</li> <li><code>--log-file PATH</code>: Redirect logs to a specific file.</li> </ul>"},{"location":"user_guide/cli/#project-management","title":"Project Management","text":""},{"location":"user_guide/cli/#qps-init","title":"<code>qps init</code>","text":"<p>Initializes a new QPhase project in the current directory.</p> <pre><code>qps init\n</code></pre> <p>Functionality: 1.  Creates the standard directory structure:     *   <code>configs/</code>: Configuration files.     *   <code>plugins/</code>: Directory for local user plugins.     *   <code>runs/</code>: Output directory for simulation results. 2.  Generates a default <code>configs/global.yaml</code> file.</p>"},{"location":"user_guide/cli/#simulation-execution","title":"Simulation Execution","text":""},{"location":"user_guide/cli/#qps-run","title":"<code>qps run</code>","text":"<p>Executes simulation jobs defined in the <code>configs/jobs/</code> directory.</p> <pre><code>qps run [JOB_NAME] [OPTIONS]\n</code></pre> <ul> <li>Arguments:<ul> <li><code>JOB_NAME</code>: The name of the job configuration file (without extension) located in <code>configs/jobs/</code>.</li> </ul> </li> <li>Options:<ul> <li><code>--list</code>: List all available job configurations and exit.</li> <li><code>--verbose</code> / <code>-v</code>: Enable verbose debug logging.</li> </ul> </li> </ul> <p>Examples: <pre><code># Execute a single job\nqps run vdp_sde\n\n# List available jobs\nqps run --list\n\n# Run with verbose logging\nqps run --verbose vdp_sde\n</code></pre></p>"},{"location":"user_guide/cli/#plugin-management","title":"Plugin Management","text":""},{"location":"user_guide/cli/#qps-list","title":"<code>qps list</code>","text":"<p>Lists all registered plugins available in the current environment.</p> <pre><code>qps list [CATEGORIES]\n</code></pre> <ul> <li>Arguments:<ul> <li><code>CATEGORIES</code> (Optional): A comma-separated list of namespaces to filter by (e.g., <code>backend</code>, <code>model</code>). Use <code>.</code> to list all categories.</li> </ul> </li> </ul> <p>Example: <pre><code>qps list backend\n# Output:\n# Available Plugins\n# backend: (2 plugins)\n#   numpy  (qphase.backend.numpy)\n#   torch  (qphase.backend.torch)\n</code></pre></p>"},{"location":"user_guide/cli/#qps-show","title":"<code>qps show</code>","text":"<p>Displays detailed information about a specific plugin, including its description, source code location, and configuration schema.</p> <pre><code>qps show [PLUGIN_ID]\n</code></pre> <ul> <li>Arguments:<ul> <li><code>PLUGIN_ID</code>: The full identifier of the plugin (e.g., <code>backend.numpy</code> or <code>model.kerr_cavity</code>).</li> </ul> </li> </ul>"},{"location":"user_guide/cli/#qps-template","title":"<code>qps template</code>","text":"<p>Generates a configuration template for a specific plugin. This is useful for quickly creating new configuration files.</p> <pre><code>qps template [PLUGIN_ID]\n</code></pre> <ul> <li>Arguments:<ul> <li><code>PLUGIN_ID</code>: The full identifier of the plugin.</li> </ul> </li> </ul> <p>Example: <pre><code>qps template model.kerr_cavity\n# Output:\n# # Configuration for model.kerr_cavity\n# chi: 1.0  # Nonlinearity parameter\n# ...\n</code></pre></p>"},{"location":"user_guide/cli/#configuration-management","title":"Configuration Management","text":""},{"location":"user_guide/cli/#qps-config","title":"<code>qps config</code>","text":"<p>Manages the system configuration.</p> <p>(Detailed documentation for <code>qps config</code> subcommands to be added)</p>"},{"location":"user_guide/configuration/","title":"Configuration Guide","text":"<p>QPhase utilizes a hierarchical, YAML-based configuration system designed to ensure reproducibility, flexibility, and ease of use.</p>"},{"location":"user_guide/configuration/#configuration-schemes","title":"Configuration Schemes","text":"<p>QPhase supports two configuration schemes. We strongly recommend the Flat Scheme for most use cases due to its clarity and composability.</p>"},{"location":"user_guide/configuration/#1-flat-scheme-recommended","title":"1. Flat Scheme (Recommended)","text":"<p>In this scheme, one file represents one job. This avoids deep indentation and makes it easy to reuse jobs in different pipelines.</p> <p>File: <code>configs/jobs/my_simulation.yaml</code> <pre><code>name: my_simulation\n\n# Engine Configuration\n# The key (e.g., 'sde') determines the engine type.\nengine:\n  sde:\n    dt: 0.01\n    t_end: 100.0\n    n_traj: 1000\n\n# Plugin Configurations (Top-level keys)\n# Keys must match registered plugin types (e.g., 'model', 'backend').\nmodel:\n  kerr_cavity:\n    chi: 1.0\n    epsilon: 2.5\n\nbackend:\n  numpy:\n    float_dtype: float64\n\nintegrator:\n  euler: {}\n</code></pre></p>"},{"location":"user_guide/configuration/#2-nested-scheme-legacybatch","title":"2. Nested Scheme (Legacy/Batch)","text":"<p>In this scheme, multiple jobs are defined in a single file under a <code>jobs</code> list. This is useful for defining a strict sequence of tasks that always run together, but it can be harder to read and maintain.</p> <p>File: <code>configs/pipelines/full_pipeline.yaml</code> <pre><code>name: full_pipeline\njobs:\n  - name: step_1\n    engine:\n      sde:\n        dt: 0.01\n    model:\n      kerr_cavity:\n        chi: 1.0\n\n  - name: step_2\n    input: step_1\n    engine:\n      viz:\n        format: png\n</code></pre></p>"},{"location":"user_guide/configuration/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p>To determine the final settings for a simulation job, QPhase merges configurations from multiple sources. The priority order, from highest to lowest, is as follows:</p> <ol> <li>Job Configuration (<code>configs/jobs/*.yaml</code>): Settings specific to a single simulation run. These settings override all others.</li> <li>Global Configuration (<code>configs/global.yaml</code>): Project-wide defaults (e.g., default backend, logging preferences).</li> <li>System Defaults: Built-in defaults provided by the QPhase package and its plugins.</li> </ol>"},{"location":"user_guide/configuration/#anatomy-of-a-job-configuration","title":"Anatomy of a Job Configuration","text":"<p>A job configuration file defines the specific parameters for a simulation.</p>"},{"location":"user_guide/configuration/#key-fields","title":"Key Fields","text":"Field Type Description <code>name</code> <code>str</code> Required. A unique identifier for the job. Used for logging and output filenames. <code>engine</code> <code>dict</code> Required. Configuration for the simulation engine. Must contain exactly one key corresponding to the engine name (e.g., <code>sde</code>). <code>model</code> <code>dict</code> Optional. Configuration for the physical model plugin. <code>backend</code> <code>dict</code> Optional. Configuration for the computational backend plugin. <code>integrator</code> <code>dict</code> Optional. Configuration for the integrator plugin. <code>input</code> <code>str</code> Optional. Specifies an input source, such as the name of an upstream job. <code>output</code> <code>str</code> Optional. Specifies the output destination."},{"location":"user_guide/configuration/#parameter-scanning","title":"Parameter Scanning","text":"<p>QPhase includes built-in support for parameter sweeps.</p>"},{"location":"user_guide/configuration/#cartesian-product-grid-search","title":"Cartesian Product (Grid Search)","text":"<p>If lists are provided for multiple parameters, QPhase generates a job for every possible combination.</p> <pre><code>model:\n  kerr_cavity:\n    chi: [1.0, 2.0]\n    epsilon: [0.1, 0.5, 1.0]\n</code></pre> <p>This generates 6 jobs ($2 \\times 3$).</p>"},{"location":"user_guide/installation/","title":"Installation","text":"<p>This guide covers the installation process for QPhase and its official plugins.</p>"},{"location":"user_guide/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Operating System: Linux, macOS, or Windows (WSL2 recommended for performance).</li> <li>Python: Version 3.10 or higher.</li> <li>Git: For cloning the repository.</li> </ul>"},{"location":"user_guide/installation/#recommended-virtual-environment","title":"Recommended: Virtual Environment","text":"<p>We strongly recommend using a virtual environment to avoid conflicts with other Python packages.</p>"},{"location":"user_guide/installation/#using-conda-recommended","title":"Using Conda (Recommended)","text":"<pre><code>conda create -n qphase python=3.11\nconda activate qphase\n</code></pre>"},{"location":"user_guide/installation/#using-venv","title":"Using venv","text":"<pre><code>python -m venv .venv\n# Linux/macOS\nsource .venv/bin/activate\n# Windows\n.venv\\Scripts\\activate\n</code></pre>"},{"location":"user_guide/installation/#installation-from-source","title":"Installation from Source","text":"<p>Currently, QPhase is installed directly from the source code.</p> <ol> <li> <p>Clone the Repository</p> <pre><code>git clone https://github.com/PolarisMegrez/qphase.git\ncd qphase\n</code></pre> </li> <li> <p>Install Core Package</p> <p>Install the core framework in editable mode (<code>-e</code>), which allows you to modify the code without reinstalling.</p> <pre><code>pip install -e packages/qphase\n</code></pre> <p>For most users, we recommend installing with the <code>standard</code> optional dependencies which include commonly used packages:</p> <pre><code>pip install -e packages/qphase[standard]\n</code></pre> <p>This includes Numba (for JIT compilation) and PyTorch (for GPU acceleration).</p> </li> <li> <p>Install Official Plugins</p> <p>QPhase is modular. You can install only the components you need.</p> <ul> <li> <p>SDE Engine (Stochastic Differential Equations):     <pre><code>pip install -e packages/qphase_sde\n</code></pre></p> </li> <li> <p>Visualization Tools:     <pre><code>pip install -e packages/qphase_viz\n</code></pre></p> </li> </ul> </li> <li> <p>Install Dependencies</p> <p>If you have a <code>requirements.txt</code> file in the root, you can install it, but usually, the package installation above handles dependencies automatically.</p> <pre><code># Optional: Install development dependencies (testing, docs)\npip install -r requirements.txt\n</code></pre> </li> </ol>"},{"location":"user_guide/installation/#verification","title":"Verification","text":"<p>To verify that the installation was successful, run the following command:</p> <pre><code>qps --version\n</code></pre> <p>You should see the version number of the installed QPhase core.</p> <p>To check which plugins are detected:</p> <pre><code>qps list\n</code></pre> <p>This will display a list of registered backends, engines, and models.</p>"},{"location":"user_guide/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user_guide/installation/#command-not-found-qps","title":"\"Command not found: qps\"","text":"<p>Ensure your Python environment's <code>bin</code> (or <code>Scripts</code> on Windows) directory is in your system's PATH. If you installed in a virtual environment, make sure it is activated.</p>"},{"location":"user_guide/installation/#modulenotfounderror-no-module-named-qphase","title":"\"ModuleNotFoundError: No module named 'qphase'\"","text":"<p>This usually happens if you installed dependencies but forgot to install the package itself. Run <code>pip install -e packages/qphase</code> again.</p>"},{"location":"user_guide/quick_start/","title":"Quick Start Guide","text":"<p>This guide will help you set up QPhase and run your first simulation.</p>"},{"location":"user_guide/quick_start/#1-installation","title":"1. Installation","text":"<p>We strongly recommend using a virtual environment to keep your project dependencies clean.</p>"},{"location":"user_guide/quick_start/#step-1-create-a-virtual-environment","title":"Step 1: Create a Virtual Environment","text":"<p>Open your terminal (PowerShell or Bash) and run:</p> <pre><code># Create a virtual environment named '.venv'\npython -m venv .venv\n\n# Activate it\n# Windows (PowerShell):\n.venv\\Scripts\\Activate.ps1\n# Linux/macOS:\nsource .venv/bin/activate\n</code></pre>"},{"location":"user_guide/quick_start/#step-2-install-qphase","title":"Step 2: Install QPhase","text":"<p>Install the package using pip:</p> <pre><code>pip install qphase\n</code></pre>"},{"location":"user_guide/quick_start/#2-initialize-a-project","title":"2. Initialize a Project","text":"<p>QPhase works best when you have a dedicated folder for your simulations. This keeps your configuration files and results organized.</p> <pre><code># Create a folder for your research project\nmkdir my_research\ncd my_research\n\n# Initialize the QPhase structure\nqps init\n</code></pre> <p>This creates the following folders: *   <code>configs/</code>: Where you tell QPhase what to run. *   <code>plugins/</code>: Where you put your custom physics code. *   <code>runs/</code>: Where QPhase saves your data.</p>"},{"location":"user_guide/quick_start/#3-create-your-first-job","title":"3. Create Your First Job","text":"<p>A \"Job\" is a single simulation run. You define it in a YAML file. Create a new file named <code>configs/jobs/test_run.yaml</code> and paste the following:</p> <pre><code># configs/jobs/test_run.yaml\nname: test_run\n\n# 1. Choose the Engine (SDE Solver)\nengine:\n  sde:\n    t_end: 10.0\n    dt: 0.01\n    n_traj: 100\n\n# 2. Choose the Physics Model\n# (Here we use a built-in example model if available, or you can define your own)\n# For this example, let's assume we have a 'vdp_oscillator' model available.\n# If not, you might need to write a plugin first (see Developer Guide).\nplugins:\n  model:\n    vdp_two_mode:  # This is a built-in example model\n      D: 1.0       # Diffusion strength\n\n  backend:\n    numpy:         # Run on CPU\n      float_dtype: float64\n</code></pre>"},{"location":"user_guide/quick_start/#4-run-the-simulation","title":"4. Run the Simulation","text":"<p>Now, tell QPhase to run the job you just defined:</p> <pre><code>qps run test_run\n</code></pre> <p>You should see a progress bar: <pre><code>[INFO] Loading 1 configuration file(s)\n[INFO] Starting job execution\n[test_run] 100.0% ~00:00\n[INFO] All 1 jobs completed successfully\n</code></pre></p>"},{"location":"user_guide/quick_start/#5-check-the-results","title":"5. Check the Results","text":"<p>Look in the <code>runs/</code> folder. You will see a new directory with a timestamp:</p> <pre><code>runs/\n\u2514\u2500\u2500 2025-12-29T12-00-00Z_test_run/\n    \u251c\u2500\u2500 config_snapshot.json  # The exact settings used\n    \u2514\u2500\u2500 results.h5            # The simulation data (format depends on engine)\n</code></pre> <p>Congratulations! You have successfully run a reproducible physics simulation without writing any boilerplate code.</p>"},{"location":"user_guide/sde_modeling/","title":"SDE Modeling","text":"<pre><code>---\nlayout: default\ntitle: SDE Modeling Guide\nparent: User Guide\nnav_order: 3\n---\n\n# SDE Modeling Guide\n\nQPhase SDE adopts a three-level architecture for modeling physical systems. This hierarchy allows for separation of concerns between the physical definition (Quantum/Phase Space) and the numerical implementation (SDE).\n\n## The Three-Level Architecture\n\n### Level 1: Master Equation (ME)\n**Class:** `qphase_sde.model.MasterEquation`\n\nDescribes the system in the Hilbert space using the Hamiltonian ($\\hat{H}$) and Lindblad collapse operators ($\\hat{L}_k$). This is the most fundamental physical description.\n\n*   **Use case:** Defining the physics from first principles.\n*   **Components:** Hamiltonian, Lindblad operators.\n\n### Level 2: Phase Space Model (FPE)\n**Class:** `qphase_sde.model.PhaseSpaceModel`\n\nDescribes the system dynamics in phase space (e.g., Wigner, P-representation, Q-function). It is defined by the Kramers-Moyal expansion coefficients of the Fokker-Planck Equation (FPE).\n\n$$ \\frac{\\partial P}{\\partial t} = \\sum_{n=1}^\\infty \\frac{(-1)^n}{n!} \\frac{\\partial^n}{\\partial \\alpha^n} [D_n(\\alpha) P] $$\n\n*   **Use case:** Analytical derivation, studying phase space distributions.\n*   **Components:** Drift vector ($D_1$), Diffusion tensor ($D_2$), and potentially higher-order terms ($D_3, \\dots$).\n\n### Level 3: Stochastic Model (SDE)\n**Classes:** `qphase_sde.model.DiffusiveSDEModel`, `qphase_sde.model.JumpSDEModel`\n\nDescribes the stochastic trajectories for numerical simulation. This is the level consumed by the simulation engine.\n\n*   **DiffusiveSDEModel (Langevin):** For systems with only 1st and 2nd order terms (Gaussian noise).\n    $$ d\\mathbf{y} = \\mathbf{a}(\\mathbf{y}, t) dt + \\mathbf{b}(\\mathbf{y}, t) d\\mathbf{W} $$\n*   **JumpSDEModel:** For systems with higher-order terms mapped to jump processes.\n\n## Workflow\n\n1.  **Define Physics:** Start by defining a `PhaseSpaceModel` (Level 2) containing the drift ($D_1$) and diffusion ($D_2$) coefficients.\n2.  **Convert:** Use `qphase_sde.model.fpe_to_sde()` to automatically convert the FPE model to a `DiffusiveSDEModel` (Level 3).\n3.  **Simulate:** Pass the Level 3 model to the `Engine`.\n\nAlternatively, advanced users can define a `DiffusiveSDEModel` directly if they want manual control over the noise decomposition.\n\n## Example: Van der Pol Oscillator\n\n### Level 2 Definition\n```python\nfrom qphase_sde.model import PhaseSpaceModel\n\ndef drift_fn(y, t, p):\n    # ... calculate D1 ...\n    return d1\n\ndef diffusion_fn(y, t, p):\n    # ... calculate D2 ...\n    return d2\n\nfpe_model = PhaseSpaceModel(\n    name=\"vdp_fpe\",\n    n_modes=1,\n    terms={1: drift_fn, 2: diffusion_fn},\n    params={...}\n)\n</code></pre>"},{"location":"user_guide/sde_modeling/#conversion","title":"Conversion","text":"<p><pre><code>from qphase_sde.model import fpe_to_sde\n\nsde_model = fpe_to_sde(fpe_model)\n</code></pre> ```</p>"},{"location":"user_guide/sde_simulation/","title":"SDE Simulation Guide","text":"<p>The <code>qphase_sde</code> package provides a robust engine for solving Stochastic Differential Equations (SDEs) in the phase space. It is designed to be modular, allowing you to easily switch between different integration schemes and noise models.</p>"},{"location":"user_guide/sde_simulation/#overview","title":"Overview","text":"<p>The SDE engine solves equations of the form:</p> <p>$$ d\\mathbf{y} = \\mathbf{a}(\\mathbf{y}, t) dt + \\mathbf{b}(\\mathbf{y}, t) d\\mathbf{W} $$</p> <p>where: *   $\\mathbf{y}$ is the state vector (e.g., phase-space coordinates). *   $\\mathbf{a}(\\mathbf{y}, t)$ is the drift vector. *   $\\mathbf{b}(\\mathbf{y}, t)$ is the diffusion matrix. *   $d\\mathbf{W}$ is the Wiener process increment (noise).</p>"},{"location":"user_guide/sde_simulation/#configuration","title":"Configuration","text":"<p>To use the SDE engine, you need to specify it in your job configuration file (e.g., <code>job.yaml</code>).</p> <pre><code>engine:\n  sde:\n    dt: 1e-3              # Time step size\n    t_max: 10.0           # Total simulation time\n    n_traj: 1000          # Number of trajectories\n    integrator:           # Integrator configuration\n      name: \"srk\"         # Use the Generic SRK solver\n      method: \"heun\"      # Specific method (heun, euler)\n      tol: 1e-4           # Tolerance for adaptive stepping\n    backend: \"numpy\"      # Backend (numpy, torch, cupy)\n</code></pre>"},{"location":"user_guide/sde_simulation/#key-parameters","title":"Key Parameters","text":"Parameter Type Description <code>dt</code> <code>float</code> The base time step size. For fixed-step solvers, this is the step used. For adaptive solvers, this is the initial step guess. <code>t_max</code> <code>float</code> The end time of the simulation (starts at t=0). <code>n_traj</code> <code>int</code> The number of parallel trajectories to simulate. <code>integrator</code> <code>dict</code> Configuration for the numerical solver. <code>backend</code> <code>str</code> The computational backend to use."},{"location":"user_guide/sde_simulation/#integrators","title":"Integrators","text":"<p>The framework supports several integration schemes via the <code>GenericSRK</code> (Stochastic Runge-Kutta) class.</p>"},{"location":"user_guide/sde_simulation/#available-methods","title":"Available Methods","text":"<ul> <li> <p><code>euler</code> (Euler-Maruyama):</p> <ul> <li>Order: Strong 0.5, Weak 1.0.</li> <li>Use case: Simple additive noise or when speed is critical and high accuracy is not required.</li> <li>Interpretation: Ito.</li> </ul> </li> <li> <p><code>heun</code> (Stochastic Heun):</p> <ul> <li>Order: Strong 1.0 (approx), Weak 2.0.</li> <li>Use case: Multiplicative noise where Stratonovich interpretation is desired.</li> <li>Interpretation: Stratonovich.</li> </ul> </li> </ul>"},{"location":"user_guide/sde_simulation/#adaptive-stepping","title":"Adaptive Stepping","text":"<p>The <code>srk</code> integrator supports adaptive stepping using Richardson extrapolation (step doubling). This allows the solver to automatically reduce the step size <code>dt</code> when the error is high (e.g., during fast dynamics) and increase it when the system is stable.</p> <p>To enable adaptive stepping, simply provide a <code>tol</code> (tolerance) parameter in the integrator config.</p> <pre><code>integrator:\n  name: \"srk\"\n  method: \"heun\"\n  tol: 1e-5  # Enables adaptive stepping with target error 1e-5\n</code></pre> <p>Note: Even with adaptive stepping, the engine will interpolate the results to save data at fixed intervals defined by <code>dt</code> and <code>return_stride</code>. This ensures that your output data is always on a regular time grid, simplifying analysis.</p>"},{"location":"user_guide/sde_simulation/#defining-models","title":"Defining Models","text":"<p>To simulate a system, you need to define a model that implements the <code>SDEModel</code> protocol. This involves specifying the <code>drift</code> and <code>diffusion</code> functions.</p> <p>See the Plugin Development guide for details on how to write and register custom models.</p>"}]}