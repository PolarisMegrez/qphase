backend:
  cupy:
    device:  # Device identifier (e.g., 'cpu', 'cuda:0')
    float_dtype: float64 # Default floating-point dtype
  numba:
    device:  # Device identifier (e.g., 'cpu', 'cuda:0')
    float_dtype: float64 # Default floating-point dtype
    enable_cache: true # Enable JIT cache
    fast_math: true # Enable fast math
  numpy:
    device:  # Device identifier (e.g., 'cpu', 'cuda:0')
    float_dtype: float64 # Default floating-point dtype
    optimize_einsum: true # Enable einsum optimization
  torch:
    device:  # Device identifier (e.g., 'cpu', 'cuda:0')
    float_dtype: float64 # Default floating-point dtype
    enable_grad: false # Enable autograd
engine:
  sde:
    t0: 0.0  # Start time
    t1: 10.0 # End time
    dt: 0.001 # Time step size (initial step for adaptive)
    n_traj: 1 # Number of trajectories
    seed: # Random seed
    ic: # Initial conditions (list or array)
    adaptive: false # Enable adaptive stepping (if supported by integrator)
    atol: 1e-06 # Absolute tolerance for adaptive stepping
    rtol: 0.001 # Relative tolerance for adaptive stepping
    min_dt: 1e-09 # Minimum time step for adaptive stepping
    max_dt: 1.0 # Maximum time step for adaptive stepping
    save_stride: 1 # Save every N-th step to the result trajectory
  viz:
    output_dir: .  # Directory to save figures
    format: png # Output format (png, pdf, svg)
    specs: [] # List of plot specifications
    style_overrides: {} # Global matplotlib style overrides
integrator:
  euler_maruyama: {}
  milstein: {}
  srk:
    method: heun  # Integration scheme (euler, heun)
visualizer:
  phase_plane:
    plots: []  # List of phase plane plots to generate
  power_spectrum:
    plots: []  # List of power spectrum plots to generate
  time_series:
    plots: []  # List of time series plots to generate
