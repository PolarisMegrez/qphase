---
description: 架构概述
---

# 架构概述

本文档详细介绍了 QPhase 框架的架构设计。它面向希望了解内部机制、设计模式和系统结构决策的开发者。

## 设计理念

QPhase 的架构旨在解决科学计算的特定挑战：可复现性、模块化和硬件无关性。与临时脚本不同（在临时脚本中，仿真逻辑与基础设施代码（I/O、配置、并行化）紧密耦合），QPhase 强制执行严格的关注点分离。

### Shell-Kernel 二分法

框架在概念上分为两个不同的层：

1.  **Shell（基础设施层）**：
    *   **职责**：管理仿真的运维生命周期。这包括配置解析、依赖注入、任务调度、资源管理和结果持久化。
    *   **特征**：通用、与物理无关且稳定。它为仿真提供"运行时环境"。

2.  **Kernel（领域层）**：
    *   **职责**：封装科学逻辑。这包括物理模型（哈密顿量、漂移/扩散向量）、数值积分器和后端实现。
    *   **特征**：领域特定、模块化且可扩展。用户主要通过实现插件与此层交互。

## 核心概念

要理解 QPhase 的运作方式，必须区分三个基本概念：**任务**、**引擎**和**插件**。

### 1. 任务（"意图"）
**任务**表示单个原子执行请求。它回答的问题是：*"我想运行什么仿真？"*
*   **定义**：任务完全由其配置（已解析的 YAML 文档）定义。它包含复现仿真所需的所有参数。
*   **隔离**：每个任务在其自己的隔离目录（`runs/{timestamp}_{job_name}/`）中运行。这确保一个仿真的副作用（如文件 I/O）不会污染另一个。
*   **生命周期**：任务由调度器创建（通常通过展开参数扫描），执行，然后在其结果保存后完成。

### 2. 引擎（"工作流"）
**引擎**是一种特殊类型的插件，定义仿真的*生命周期*。它回答的问题是：*"仿真应该如何进行？"*
*   **角色**：引擎充当"主循环"或协调器。
    *   `sde` 引擎运行随机微分方程的时间步进循环。
    *   `viz` 引擎运行数据处理和绘图管道。
*   **协调**：引擎本身不执行底层物理或数学运算。相反，它请求其他插件（如模型或后端）来完成实际工作。

### 3. 插件（"构建块"）
**插件**是实现特定功能的模块化组件。插件是引擎组装以构建仿真的"乐高积木"。
*   **模型**：定义物理系统（例如漂移和扩散向量）。
*   **后端**：提供计算原语（例如 NumPy 用于 CPU，PyTorch 用于 GPU）。
*   **积分器**：实现数值求解器（例如 Euler-Maruyama）。
*   **分析器**：将原始仿真数据处理成指标。

### 关系：依赖注入
QPhase 的强大之处在于这些组件如何连接。您不需要编写代码来将它们连接在一起；**调度器**会根据配置为您完成。

1.  **选择**：**任务**配置选择一个**引擎**（例如 `engine: sde`）。
2.  **声明**：**引擎**通过**清单**声明它需要什么（例如"我需要一个 `model` 和一个 `backend`"）。
3.  **注入**：**调度器**读取清单，在任务配置中查找请求的插件，通过**注册表**实例化它们，并将它们*注入*到引擎的构造函数中。

## 核心架构模式

### 1. 注册表模式与依赖注入

为了实现模块化，QPhase 避免硬编码依赖。相反，它使用**注册表模式**结合**依赖注入**。

*   **注册表**：一个集中的单例（`RegistryCenter`），维护组件名称（字符串）到其实现（类/工厂）的动态映射。这允许在运行时通过配置文件选择组件。
*   **依赖注入**：当 `Engine` 被实例化时，它不直接实例化其依赖项（模型、后端）。相反，`Scheduler` 通过注册表解析这些依赖项并将它们注入到引擎的构造函数中。这种控制反转有助于测试和组件交换。

### 2. 后端抽象（张量调度）

现代科学计算的一个关键要求是硬件可移植性（CPU vs GPU）。QPhase 通过**后端抽象**来解决这个问题。

*   **问题**：直接使用 `numpy` 或 `torch` 等库会将仿真代码耦合到特定的硬件后端。
*   **解决方案**：框架定义了一个 `BackendBase` 协议，指定张量操作的标准接口。
*   **实现**：具体实现（`NumpyBackend`、`TorchBackend`）包装底层库。仿真内核专门与抽象接口交互（按惯例命名为 `xp`），允许底层执行引擎通过配置切换而无需更改代码。

### 3. 结构化子类型（协议）

QPhase 利用 Python 的 `typing.Protocol`（PEP 544）进行接口定义，而不是抽象基类（ABC）。

*   **理由**：这强制执行**结构化子类型**（鸭子类型）而非名义子类型。如果一个类实现了所需的方法，则它被视为有效的插件，无论其继承层次结构如何。
*   **好处**：这减少了用户代码与框架核心之间的耦合。研究人员可以在不导入框架特定基类的情况下开发插件，从而简化分发和测试。

### 4. 显式依赖契约（清单）

为了确保松耦合系统中的健壮性，QPhase 采用**显式依赖契约**。

*   **问题**："盲目"依赖注入可能导致运行时错误，如果引擎需要用户未配置的插件（例如特定的模型类型）。
*   **解决方案**：引擎通过 `EngineManifest` 静态声明其依赖项。
*   **机制**：`Scheduler` 在执行开始*之前*验证任务配置是否符合引擎的清单，确保所有必需的插件都存在且类型正确。

## 执行生命周期

仿真的执行遵循由 `Scheduler` 管理的确定性生命周期：

1.  **初始化**：CLI 入口点初始化应用程序上下文并加载系统配置。
2.  **发现**：注册表扫描入口点和本地目录以填充组件目录。
3.  **配置解析**：加载任务配置，根据 Pydantic 模式验证，并与全局默认值合并。
4.  **验证**：调度器验证任务依赖项是否符合目标引擎的 `EngineManifest`。
5.  **任务展开**：处理参数扫描，将高级任务定义展开为原子执行单元列表（`JobConfig`）。
6.  **执行循环**：
    *   **隔离**：配置唯一的运行目录。
    *   **快照**：将已解析的配置序列化到 `config_snapshot.json` 以确保可复现性。
    *   **实例化**：通过注册表实例化 `Engine` 及其依赖项。
    *   **仿真**：执行引擎的 `run()` 方法运行物理循环。
    *   **持久化**：序列化结果并刷新到磁盘。

## 目录结构

项目采用由 `uv` 工作区管理的 monorepo 结构。

### 源代码 (`packages/`)
*   `qphase/`：**核心框架（Shell）**。
    *   `core/`：调度器、注册表、配置、协议。
    *   `commands/`：CLI 实现。
*   `qphase_sde/`：**标准引擎**。
    *   实现 SDE 求解器（Euler-Maruyama、SRK）。
    *   包含标准物理模型（Kerr 腔、VdP）。
*   `qphase_viz/`：**可视化引擎**。
    *   处理绘图和数据后处理。

### 运行时产物 (`runs/`)
执行仿真时，QPhase 按层次结构组织输出：

```text
runs/
├── 2025-12-29T10-00-00Z_scan_job_0/   # 任务 1 (chi=0.1)
│   ├── config_snapshot.json           # 此特定点的完整配置
│   └── results.h5                     # 仿真数据
├── 2025-12-29T10-00-05Z_scan_job_1/   # 任务 2 (chi=0.2)
│   ├── config_snapshot.json
│   └── results.h5
└── ...
```
