---
description: 调度器系统
---

# 调度器系统

**调度器**是 QPhase 的执行编排层。它负责将高级任务定义转换为具体的计算任务，管理其生命周期，并确保数据完整性。

## 功能职责

1.  **任务展开**：将抽象任务配置（可能包含参数范围）转换为原子任务的线性序列。
2.  **依赖解析**：分析执行图以确保任务按拓扑顺序执行（例如确保输入数据在依赖任务启动前存在）。
3.  **上下文管理**：为每个任务配置隔离的执行环境（目录），以防止数据污染。
4.  **错误处理**：拦截运行时异常以防止批量失败（即单个失败的任务不应终止整个活动）。

## 依赖验证

调度器通过 `EngineManifest` 强制执行引擎声明的显式依赖契约。

1.  **清单声明**：每个引擎声明其必需和可选的插件。
    ```python
    class MyEngine(EngineBase):
        manifest = EngineManifest(
            required_plugins={"backend", "model"},
            optional_plugins={"analyser"}
        )
    ```
2.  **预检查**：在执行任何任务之前，调度器验证任务配置是否提供了目标引擎声明的所有 `required_plugins`。这可以防止由于缺少依赖项而导致的运行时失败。

## 插件实例化

对于每个任务，调度器执行以下步骤来实例化环境：

1.  **引擎解析**：首先实例化 `engine` 插件。
2.  **清单检查**：调度器读取 `engine.manifest`。
3.  **依赖注入**：调度器遍历 `required_plugins` 和 `optional_plugins`。
    *   在任务配置中查找相应的配置。
    *   为每个插件调用 `registry.create()`。
    *   将这些实例收集到字典中。
4.  **引擎执行**：最后，使用实例化插件的字典初始化引擎并启动仿真。

## 执行图

虽然当前实现主要支持串行执行，但底层数据结构（`JobList`）设计为有向无环图（DAG）。

### JobResult 封装

每次执行的结果都封装在 `JobResult` 对象中，作为调度器和报告系统之间的契约。

```python
@dataclass
class JobResult:
    job_index: int           # 拓扑索引
    job_name: str            # 唯一标识符
    run_dir: Path            # 隔离的输出目录
    run_id: str              # 带时间戳的 UUID
    success: bool            # 执行状态
    error: str | None = None # 失败时的异常跟踪
```

## 参数扫描逻辑

调度器与 `JobExpander` 集成以支持参数扫描。此过程将单个"任务定义"（可能包含值列表）转换为多个原子"任务配置"。

### 检测机制
`JobExpander` 检查配置字典中的列表。
*   **可扫描参数**：默认情况下，在插件配置中找到的**任何列表**（例如 `model.chi: [0.1, 0.2, 0.3]`）都被视为要扫描的参数。
*   **不可扫描列表**：要将列表作为字面值传递（例如向量 `[1, 0, 0]`），插件必须在其模式中显式将该字段标记为不可扫描，或者用户必须将其包装（依赖于实现，目前如果插件将列表注册为可扫描，则所有列表都是展开的候选）。

### 展开策略
1.  **笛卡尔积（默认）**：
    *   如果多个参数是列表，QPhase 生成每种可能的组合。
    *   示例：`A=[1, 2]`，`B=[3, 4]` -> `(1,3), (1,4), (2,3), (2,4)`。
    *   结果：4 个单独的任务。

2.  **压缩展开**：
    *   同步迭代参数。要求所有列表具有相同的长度。
    *   示例：`A=[1, 2]`，`B=[3, 4]` -> `(1,3), (2,4)`。
    *   结果：2 个单独的任务。

## 运行时隔离和会话管理

QPhase 使用**基于会话的 I/O** 策略来管理执行上下文。

### 会话结构
每个执行命令（例如 `qphase run ...`）启动一个新的**会话**。会话充当该命令中执行的所有任务的容器，为数据交换和日志记录提供共享上下文。

**目录布局：**
```text
runs/
  2025-12-31T10-00-00_a1b2c3/      <-- 会话根（时间戳 + 短 UUID）
    ├── session_manifest.json      <-- 会话元数据和状态
    ├── job_01_sde/                <-- 任务目录
    │     ├── config_snapshot.json
    │     └── result.h5
    └── job_02_viz/                <-- 任务目录
          ├── config_snapshot.json
          └── plot.png
```

### 会话清单
`session_manifest.json` 文件作为会话的"大脑"，记录：
- **会话 ID**：唯一标识符。
- **状态**：全局状态（运行中、已完成、失败）。
- **任务注册表**：所有任务、其状态、输出路径和依赖项的映射。

此清单启用下游功能，如**恢复功能**（重新启动失败的任务）和 **DAG 可视化**。

### 任务隔离
在会话内，每个任务在其自己的子目录（`session_dir / job_name`）中运行。
*   **并发安全**：任务写入独占路径。
*   **可追溯性**：每个目录包含一个 `config_snapshot.json`，记录该特定运行使用的*确切*标量值。
